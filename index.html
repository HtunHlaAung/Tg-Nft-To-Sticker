<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MagicMall NFT Gift to Telegram Sticker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <style>
        /* CSS VARIABLES for Theming */
        :root {
            /* Light Mode Defaults */
            --bg-start: #f0f4f9;
            --bg-end: #e7f1fc;
            --container-bg: rgba(255, 255, 255, 0.1);
            --container-border: rgba(255, 255, 255, 0.3);
            --text-color-primary: #173f5f;
            --text-color-secondary: #4a4a4a;
            --input-bg: rgba(255, 255, 255, 0.7);
            --particle-color: rgba(23, 63, 95, 0.5); 
            --button-primary: #0088cc;
            --button-primary-hover: #0077b3;
            --button-secondary: #333;
            --button-secondary-hover: #1a1a1a;
            --focus-glow: #0088cc; 
            --validation-color-error: #f33; 
            --validation-color-success: #00c853;

            /* Telegram UI Colors (Light Mode) */
            --tg-card-bg: #ffffff;
            --tg-card-border: #e0e0e0;
            --tg-divider: #f0f0f0;
            --tg-label-color: #707070;
            --tg-value-color: #333333;
            --tg-button-secondary-bg: #f0f4f9; /* Added for percentage mark bg */
        }

        .dark-mode {
            --bg-start: #0f172a;
            --bg-end: #1e293b;
            --container-bg: rgba(0, 0, 0, 0.25);
            --container-border: rgba(255, 255, 255, 0.1);
            --text-color-primary: #f1f5f9;
            --text-color-secondary: #cbd5e1;
            --input-bg: rgba(255, 255, 255, 0.15);
            --particle-color: rgba(255, 255, 255, 0.3);
            --button-primary: #2d94d7;
            --button-primary-hover: #1f80c0;
            --button-secondary: #555;
            --button-secondary-hover: #777;
            --focus-glow: #2d94d7;
            --validation-color-error: #f66;
            --validation-color-success: #69f0ae;

            /* Telegram UI Colors (Dark Mode) */
            --tg-card-bg: #1c2732; /* Deep Blueish Gray */
            --tg-card-border: #2a3540;
            --tg-divider: #2a3540;
            --tg-label-color: #aebacd; /* Lighter Gray for labels */
            --tg-value-color: #f1f5f9; /* Near White for values */
            --tg-button-secondary-bg: #2a3540; /* Added for percentage mark bg */
        }

        /* KEYFRAMES for Animation */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.03); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes bounceIn {
            0%, 20%, 40%, 60%, 80%, 100% {
                -webkit-transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
            }
            0% { opacity: 0; -webkit-transform: scale3d(.3, .3, .3); transform: scale3d(.3, .3, .3); }
            20% { -webkit-transform: scale3d(1.1, 1.1, 1.1); transform: scale3d(1.1, 1.1, 1.1); }
            40% { -webkit-transform: scale3d(.9, .9, .9); transform: scale3d(.9, .9, .9); }
            60% { opacity: 1; -webkit-transform: scale3d(1.03, 1.03, 1.03); transform: scale3d(1.03, 1.03, 1.03); }
            80% { -webkit-transform: scale3d(.97, .97, .97); transform: scale3d(.97, .97, .97); }
            100% { opacity: 1; -webkit-transform: scale3d(1, 1, 1); transform: scale3d(1, 1, 1); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* PARTICLE CANVAS */
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* BASE & CONTAINER */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: var(--text-color-primary);
            transition: background 0.5s ease;
            background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%); 
        }

        .container {
            position: relative;
            z-index: 10;
            background: var(--container-bg);
            padding: 50px; 
            border-radius: 20px; 
            backdrop-filter: blur(25px); 
            -webkit-backdrop-filter: blur(25px); 
            border: 1px solid var(--container-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2); 
            width: 100%;
            max-width: 480px;
            text-align: center;
            box-sizing: border-box; 
            animation: fadeInUp 0.8s ease-out;
            transition: background-color 0.5s, border-color 0.5s;
        }

        /* THEME TOGGLE (Animated Icon) */
        .theme-toggle {
            position: fixed; 
            top: 20px;       
            right: 20px;     
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(10px);
            border: 1px solid var(--container-border);
            cursor: pointer;
            padding: 10px; 
            border-radius: 10px; 
            transition: all 0.3s;
            color: var(--text-color-primary);
            opacity: 0.8; 
            z-index: 100; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            width: 40px; 
            height: 40px; 
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .theme-toggle:hover {
            transform: scale(1.05);
            opacity: 1;
        }
        .theme-toggle span {
            font-size: 1.2rem;
            transition: transform 0.5s ease-in-out, opacity 0.5s;
            display: inline-block;
        }
        .dark-mode .theme-toggle span {
            transform: rotate(360deg);
        }

        /* SQUARE PREVIEW BOX STYLING */
        #lottie-preview {
            width: 100%;
            padding-bottom: 100%; /* Enforces 1:1 aspect ratio */
            position: relative;
            background: var(--container-bg); 
            border-radius: 15px;
            border: 1px solid var(--container-border);
            margin-bottom: 25px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none; 
        }

        #lottie-preview.active {
            display: block;
        }

        .preview-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-color-secondary);
            text-align: center;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
        }

        #lottie-preview svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important; 
            height: 100% !important;
        }

    /* ----------------------------------- */
    /* GIFT DETAILS BOX STYLING (TELEGRAM UI STYLE) */
    /* ----------------------------------- */
    #giftDetails {
        margin-top: 15px; 
        padding: 0; 
        /* Use Telegram-style border and background */
        border: 1px solid var(--tg-card-border); 
        border-radius: 15px; 
        display: none; 
        background: var(--tg-card-bg); 
        text-align: left;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        transition: background 0.5s, border-color 0.5s;
        margin-bottom: 25px; 
        overflow: hidden; /* Important for border-radius on children */
    }

    /* Style for each detail line */
    /* *** CRITICAL FIX: Changed align-items to flex-start and removed truncation *** */
    #giftDetails .detail-line {
        display: flex;
        justify-content: space-between;
        align-items: flex-start; /* CRITICAL: Aligns to the top so multi-line text doesn't center */
        padding: 12px 20px; 
        font-size: 1.05em;
        color: var(--tg-value-color); 
        flex-wrap: wrap; /* Allows content to wrap to the next line */
    }

    /* Separator line for traits - Mimics Telegram dividers */
    #giftDetails .detail-line:not(:last-child) {
        border-bottom: 1px solid var(--tg-divider); 
    }
    /* Ensure the last line doesn't have a bottom border unless it's the error message */
    #giftDetails .detail-line:last-child {
        border-bottom: none;
    }


    /* Style for the Label (Model, Backdrop, Symbol) */
    #giftDetails .detail-line strong {
        font-weight: normal; 
        color: var(--tg-label-color);
        flex-shrink: 0; /* Prevents the label from shrinking */
        max-width: 40%; /* Reserve space for the label */
        padding-right: 10px; /* Space between label and wrapping value */
        text-align: left;
    }

    /* Style for the Value (Strawberry, Sky Blue, Sun Lion) */
    /* *** CRITICAL FIX: Removed truncation properties and allowed wrap *** */
    #giftDetails .detail-value {
        font-weight: normal; 
        color: var(--tg-value-color);
        text-align: right;
        
        /* Removed all truncation properties: */
        /* overflow: hidden; */
        /* text-overflow: ellipsis; */
        
        /* New Properties for Wrapping */
        white-space: normal !important; /* CRITICAL: Allows the text to wrap */
        word-break: break-word; 
        
        flex-basis: auto; 
        flex-grow: 1; 
        min-width: 50%; /* Give it a minimum width on its line */
        margin-left: 0; 
        display: block; /* Helps manage wrapping within the line */
    }

    /* Style for error message inside gift details */
    #giftDetails p.error-message {
        color: var(--validation-color-error);
        font-weight: bold;
        text-align: center;
        padding: 15px 20px;
        margin: 0; 
    }
    /* ----------------------------------- */


        /* INPUT FIELD & VALIDATION STYLES */
        .input-group {
            position: relative;
            margin-bottom: 20px;
        }
        input[type="text"] {
            width: 100%;
            padding: 15px 45px 15px 15px;
            border: 1px solid var(--container-border);
            border-radius: 15px; 
            font-size: 1em;
            box-sizing: border-box; 
            transition: border-color 0.3s, background 0.5s, color 0.5s, box-shadow 0.3s;
            background: var(--input-bg);
            color: var(--text-color-primary);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        input[type="text"]:focus {
             border-color: transparent;
             outline: none;
             box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 0 15px var(--focus-glow);
        }

        .validation-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2em;
            pointer-events: none;
            transition: opacity 0.3s, color 0.3s;
            opacity: 0;
        }

        input[data-valid="true"] { border: 2px solid var(--validation-color-success); }
        input[data-valid="true"] + .validation-icon {
            color: var(--validation-color-success);
            opacity: 1;
            animation: bounceIn 0.6s;
        }

        input[data-valid="false"] { border: 2px solid var(--validation-color-error); }
        input[data-valid="false"] + .validation-icon {
            color: var(--validation-color-error);
            opacity: 1;
            animation: bounceIn 0.6s;
        }


        /* BUTTONS */
        .action-buttons {
            display: flex;
            flex-direction: column; 
            gap: 10px; 
            margin-bottom: 10px;
        }
        button {
            background-color: var(--button-primary);
            color: white;
            padding: 14px 30px; 
            border: none;
            border-radius: 15px; 
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.3s;
            width: 100%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); 
        }
        button:hover:not(:disabled):not(.loading) {
            background-color: var(--button-primary-hover);
            transform: translateY(-2px); 
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3), 0 0 15px var(--button-primary); 
        }
        button:active:not(:disabled):not(.loading) {
            transform: scale(0.97);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        /* Button loading state */
        button.loading {
            animation: pulse 1.2s infinite ease-in-out;
            pointer-events: none; 
            background-color: var(--button-primary-hover); 
            transform: none !important; 
        }


        /* STATUS AND PROGRESS BAR */
        #status-area { 
            position: relative;
            margin-top: 25px;
        }
        #status {
            padding: 20px; 
            border-radius: 20px; 
            font-weight: bold;
            text-align: left;
            line-height: 1.4;
            transition: background-color 0.5s, border-color 0.5s;
        }

        /* CSS Spinner for loading status */
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--text-color-primary); 
            border-radius: 50%;
            width: 1em;
            height: 1em;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 0.5em;
        }
        .dark-mode .spinner {
            border-top: 3px solid var(--text-color-primary);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: var(--input-bg);
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background-color: var(--button-primary);
            transition: width 0.4s ease-in-out;
        }

        .error {
            background-color: rgba(255, 237, 237, 0.8); 
            color: #cc0000;
            border: 1px solid #cc0000;
        }
        .dark-mode .error {
            background-color: rgba(65, 0, 0, 0.6); 
            color: #ff9999;
            border: 1px solid #ff9999;
        }
        .success {
            background-color: rgba(237, 255, 241, 0.8); 
            color: #008800;
            border: 1px solid #008800;
        }
        .dark-mode .success {
            background-color: rgba(0, 65, 0, 0.6); 
            color: #99ff99;
            border: 1px solid #008800;
        }
        .loading {
            color: var(--button-primary);
            background-color: rgba(240, 248, 255, 0.8);
            border: 1px solid var(--button-primary);
        }
        .dark-mode .loading {
            color: #94d8ff;
            background-color: rgba(0, 30, 60, 0.6);
            border: 1px solid #94d8ff;
        }
        #status a {
            color: var(--button-primary);
            text-decoration: none;
            font-weight: normal;
        }
        #status a:hover {
            text-decoration: underline;
        }

        /* Success Lottie Animation Container */
        #success-lottie-container {
            position: absolute;
            top: -60px; /* Position above the status box */
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }
        #success-lottie-container.show {
            opacity: 1;
        }

        /* --- New/Modified Styles for Full Text Wrap --- */

        /* Style for the percentage text to match Telegram's design */
        .detail-value .percentage-mark {
            font-size: 0.85em; 
            font-weight: 500;
            color: var(--text-color-secondary); 
            margin-left: 6px;
            padding: 2px 4px;
            background: var(--tg-button-secondary-bg); 
            border-radius: 4px;
            white-space: nowrap; 
            text-decoration: none;
        }

        /* --- CRITICAL FIX: Ensure Detail Line is a Flexible Container and allows wrap --- */
        .detail-line {
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; /* CRITICAL: Aligns to the top so multi-line text doesn't center */
            padding: 12px 20px; 
            border-bottom: 1px solid var(--tg-divider);
            font-size: 1.05em;
            flex-wrap: wrap; /* CRITICAL: Allows content (label and value) to wrap if needed */
        }

        /* Ensure the label text is always fully visible and doesn't shrink */
        .detail-line strong {
            flex-shrink: 0; 
            max-width: 40%; 
            padding-right: 10px; 
            text-align: left;
        }


        /* --- CRITICAL FIX: Allow the detail-value span to wrap --- */
        .detail-line .detail-value {
            font-weight: normal; 
            color: var(--tg-value-color);
            
            /* CRITICAL: Allow the text to wrap */
            white-space: normal !important; 
            word-break: break-word; 
            
            text-align: right;
            
            /* Allow the value to take up the rest of the line and wrap if necessary */
            flex-basis: auto; 
            flex-grow: 1; 
            min-width: 50%; 
            margin-left: 0; 
            display: block; /* Make the value a block to better manage wrapping within the line */
        }


        /* --- Special Gifted Line Styling (Adjusted for wrap) --- */
        .detail-line:has(strong:contains("Gifted")) {
            font-size: 0.9em; 
            padding-top: 8px; 
            padding-bottom: 8px;
            border-bottom: none; 
            /* Align the label correctly */
            align-items: flex-start;
        }

        .detail-line:has(strong:contains("Gifted")) .detail-value {
            color: var(--text-color-secondary) !important;
            width: 100%; /* Allows it to occupy its own line */
            margin-top: 4px; /* Space from the label above it */
            text-align: right;
        }

    </style>
</head>
<body>

    <canvas id="particle-canvas"></canvas>

    <button id="themeToggle" class="theme-toggle" aria-label="Toggle dark and light mode">
        <span id="themeIcon">üåô</span>
    </button>

    <div class="container">
        <h1>MagicMall NFT Gift to Telegram Sticker</h1>

        <p class="description" id="input-description">Public Telegram NFT link ·ÄÄ·Ä≠·ÄØ·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·Äô·Äæ·Ä¨·Äë·Ää·Ä∫·Ä∑·Äï·Ä±·Ä∏·Äï·Ä´·Åã Link format: <code>t.me/nft/NFT-ID</code></p>

        <div id="lottie-preview">
            <div class="preview-placeholder">üîó Link ·Äë·Ää·Ä∑·Ä∫·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·ÄÄ ·Äí·ÄÆ·Äî·Ä±·Äõ·Ä¨·Äô·Äæ·Ä¨ Gift animation ·ÄÄ·Ä≠·ÄØ·Äï·Äº·Äû·Äï·Ä±·Ä∏·Äï·Ä´·Äú·Ä≠·Äô·Ä∫·Ä∑·Äô·Äö·Ä∫·Åã</div>
        </div>

        <div class="input-group">
            <input 
                type="text" 
                id="nftLink" 
                placeholder="üîó NFT Link t.me/nft/ID link ·ÄÄ·Ä≠·ÄØ·Äí·ÄÆ·Äô·Äæ·Ä¨·Äë·Ää·Ä∑·Ä∫·Äï·Ä´·Åã" 
                aria-describedby="input-description"
                aria-required="true"
            >
            <span class="validation-icon" id="validationIcon"></span>
        </div>
        
        <div id="giftDetails"></div>
        
        <div class="action-buttons">
            <button id="convertButton" disabled aria-disabled="true">Telegram Sticker·Äû·Ä≠·ÄØ·Ä∑·Äï·Äº·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏·Äï·Äº·ÄÆ·Ä∏Download·ÄÜ·ÄΩ·Ä≤·Äô·Ää·Ä∫·Åã</button>
            <button id="downloadJsonButton" style="display: none;">JSON file ·Ä°·Ä¨·Ä∏Download ·ÄÜ·ÄΩ·Ä≤·Äô·Ää·Ä∫ üíæ</button>
            <button id="optimizeButton" style="display: none;">Optimization tool ·Äû·Ä≠·ÄØ·Ä∑·Äû·ÄΩ·Ä¨·Ä∏·Äõ·Äî·Ä∫ üõ†Ô∏è</button>
        </div>

        <div id="status-area">
            <div id="success-lottie-container"></div>
            <div id="status" role="alert" aria-live="polite"></div>
        </div>
    </div>

  <script>
    // Global state variables
    const TELEGRAM_TGS_LIMIT_KB = 64; 
    const TELEGRAM_TGS_LIMIT_BYTES = TELEGRAM_TGS_LIMIT_KB * 1024;
    const LINK_REGEX = /t\.me\/nft\/([a-zA-Z0-9_-]+)/;
    const LOTTIE_FRAGMENT_BASE = 'https://nft.fragment.com/gift/';
    // This CORS proxy is used to bypass browser restrictions when fetching the HTML page.
    const CORS_PROXY = 'https://api.allorigins.win/get?url='; 

    let currentNftId = null;
    let currentLottieAnimation = null;
    let fetchedLottieJsonText = null;
    let lastLoadedNftId = null; 
    let successLottieAnimation = null; 
    let fetchAbortController = null;
    let animationId = null; 

    // Lottie JSON for a simple checkmark success animation
    const successCheckmarkLottie = {
        "v": "5.7.4", "fr": 30, "ip": 0, "op": 60, "w": 100, "h": 100, "nm": "Success Checkmark", "ddd": 0, "assets": [],
        "layers": [{"ddd": 0, "ind": 1, "ty": 4, "nm": "Checkmark", "sr": 1, "ks": {"o": {"a": 0, "k": 100, "ix": 11}, "rp": {"a": 0, "k": 0, "ix": 12}, "s": {"a": 0, "k": [100, 100, 100], "ix": 6}, "p": {"a": 0, "k": [50, 50, 0], "ix": 2}, "a": {"a": 0, "k": [0, 0, 0], "ix": 1}, "r": {"a": 0, "k": 0, "ix": 10}}, "ao": 0, "shapes": [{"ty": "gr", "nm": "Group 1", "it": [{"ty": "sh", "nm": "Path 1", "ind": 0, "ks": {"a": 0, "k": {"i": [[-1.2, 0], [0, -1.2], [1.2, 0]], "o": [[0, -1.2], [1.2, 0], [0, 1.2]], "v": [[28.5, 52.8], [42.6, 66.8], [71.5, 37.9]]}, "ix": 2}, "mn": "ADBEVectorShape", "hd": false}, {"ty": "st", "c": {"a": 0, "k": [0, 0.8, 0.4, 1], "ix": 3}, "o": {"a": 0, "k": 100, "ix": 4}, "w": {"a": 0, "k": 10, "ix": 5}, "lc": 1, "lj": 1, "ml": 4, "mn": "ADBEVectorGraphicStroke", "hd": false}, {"ty": "gr", "nm": "Group 2", "it": [], "mn": "ADBEVectorGroup", "hd": false}], "mn": "ADBEVectorGroup", "hd": false}], "bm": 0}]
    };

    // ===================================
    // CORE UI DISPLAY FUNCTIONS (UPDATED)
    // ===================================

    // **UPDATED UI DISPLAY FUNCTION: Uses the new object structure and applies percentage styling.**
    function showGiftDetails(details, isError = false) { 
        const detailBox = document.getElementById("giftDetails");
        
        // Clear the box first
        detailBox.innerHTML = '';
        
        // Destructure, noting model, backdrop, and symbol are now objects {name, percent} OR strings (from fallback)
        const { giftId, model, backdrop, symbol, owner, quantity, giftedBy, giftedTo, giftedDate } = details;

        // Handle error state
        if (isError) {
            detailBox.innerHTML = `
                <p class="error-message">‚ùå Gift Details Not Found. CORS Proxy failed or HTML structure changed.</p>
            `;
            detailBox.style.display = "block";
            return;
        }

        // Check if any metadata exists (handles both string and object traits)
        const hasMetadata = Object.values(details).some(value => {
            if (typeof value === 'object' && value !== null) {
                return value.name && value.name !== "Unknown" && value.name !== "-";
            }
            return value && value !== "Unknown" && value !== "-";
        });
                    
        if (!hasMetadata) {
            detailBox.style.display = "none";
            return;
        }

        let htmlContent = '';

        // Helper function to create the desired format line
        // **MODIFIED: Now accepts trait objects and formats the percentage mark**
        const createDetailLine = (label, value) => {
            let displayValue = '';
            let actualValue = '';

            if (typeof value === 'object' && value !== null && value.name) {
                // Handle Trait objects {name, percent}
                actualValue = value.name;
                if (value.percent) {
                    // Apply the new Telegram-style class for the percentage
                    // NOTE: The percentage mark is wrapped in a <span> inside the main detail-value span.
                    displayValue = `${actualValue} <span class="percentage-mark">${value.percent}</span>`;
                } else {
                    displayValue = actualValue;
                }
            } else {
                // Handle simple strings (Gift ID, Owner, Quantity, etc. or fallback traits)
                actualValue = typeof value === 'string' ? value : 'Unknown';
                displayValue = actualValue;
            }

            if (actualValue && actualValue !== 'Unknown' && actualValue !== '-') {
                // CRITICAL: Notice the inline style override is removed, relying on the new CSS for wrapping
                return `<div class="detail-line">
                            <strong>${label}</strong>
                            <span class="detail-value">${displayValue}</span>
                        </div>`;
            }
            return '';
        };

        // 1. Gift ID 
        let formattedGiftId = giftId;
        if (giftId && giftId !== 'Unknown' && giftId !== '-') {
            // Find the numeric ID from the original link slug (e.g., SpicedWine-45298)
            const idMatch = details.nftLinkFull ? details.nftLinkFull.match(/-(\d+)$/) : null;
            let numericId = idMatch ? idMatch[1] : '';

            // Add the # and numeric ID to the display
            if (numericId) {
                formattedGiftId = `${giftId} #${numericId}`;
            }
            
            // Avoid showing Gift ID if it's identical to the Model name
            const modelName = typeof model === 'object' && model.name ? model.name : (typeof model === 'string' ? model : '');
            const modelMatch = modelName.split(' ')[0];

            if (!modelName || modelName === 'Unknown' || giftId.toLowerCase() !== modelMatch.toLowerCase()) {
                htmlContent += createDetailLine('Gift ID', formattedGiftId);
            }
        }

        // 2. Model Trait
        htmlContent += createDetailLine('Model', model);

        // 3. Backdrop Trait
        htmlContent += createDetailLine('Backdrop', backdrop);
        
        // 4. Symbol Trait
        htmlContent += createDetailLine('Symbol', symbol);

        // Add a visual separator if we have traits AND other metadata
        const getTraitName = (trait) => (typeof trait === 'object' && trait.name) ? trait.name : trait;

        const hasTraits = (getTraitName(model) !== 'Unknown' && getTraitName(model) !== '-') || 
                            (getTraitName(backdrop) !== 'Unknown' && getTraitName(backdrop) !== '-') || 
                            (getTraitName(symbol) !== 'Unknown' && getTraitName(symbol) !== '-');
        
        const hasOwnerOrQuantity = (owner && owner !== 'Unknown' && owner !== '-') || (quantity && quantity !== 'Unknown' && quantity !== '-');

        if (hasTraits && hasOwnerOrQuantity) {
             htmlContent += `<div class="detail-line" style="border-bottom: 1px solid var(--tg-divider); background: var(--tg-card-bg);"></div>`;
        }

        // 5. Owner
        htmlContent += createDetailLine('Owner', owner);

        // 6. Quantity (Format number with commas)
        let formattedQuantity = quantity;
        if (quantity && quantity !== 'Unknown' && quantity !== '-') {
            // 1. Remove non-numeric/non-slash/non-comma characters (like "issued")
            formattedQuantity = quantity.replace(/[^0-9\/\s,]/g, '').trim(); 
            
            // 2. Remove all internal spaces (e.g., "96 123" -> "96123")
            formattedQuantity = formattedQuantity.replace(/\s+/g, ''); 
            
            // 3. Add commas to both parts of a fraction (x/y)
            formattedQuantity = formattedQuantity.split('/').map(part => {
                // Remove existing commas before re-applying for clean formatting
                let numStr = part.replace(/,/g, '').trim(); 
                // Add commas back: look for a digit followed by groups of three digits
                return numStr.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,'); 
            }).join(' / '); // Add spaces around the slash for cleaner output
        }
        htmlContent += createDetailLine('Quantity', formattedQuantity);

        // 7. Gift Note (Combine Sender, Recipient, and Date)
        let giftNote = null;
        if (giftedBy && giftedBy !== 'Unknown' && giftedBy !== '-') {
            if (giftedTo && giftedTo !== 'Unknown' && giftedTo !== '-') {
                giftNote = `by ${giftedBy} to ${giftedTo}`;
            } else {
                giftNote = `by ${giftedBy}`;
            }
            if (giftedDate && giftedDate !== 'Unknown' && giftedDate !== '-') {
                 giftNote += ` on ${giftedDate}`;
            }
        } else if (giftedDate && giftedDate !== 'Unknown' && giftedDate !== '-') {
             // Fallback if we only have the date
             giftNote = `on ${giftedDate}`;
        }
        
        // Create Gift Note line only if we have the content
        if (giftNote) {
        // CRITICAL: The inline styles are removed and rely on the new CSS for wrapping
        htmlContent += `<div class="detail-line" style="font-size: 0.9em; padding-top: 8px; padding-bottom: 8px;">
                            <strong style="font-weight: bold; color: var(--text-color-primary);">Gifted</strong>
                            <span class="detail-value" style="color: var(--text-color-secondary);">${giftNote}</span> 
                            </div>`;
    }

        // Inject the generated content
        detailBox.innerHTML = htmlContent;

        detailBox.style.display = "block";
    }


    function resetGiftDetails() {
        const detailBox = document.getElementById("giftDetails");
        // Clear all dynamically added content
        detailBox.innerHTML = ''; 
        detailBox.style.display = "none";
    }

    function resetPreview() {
        const previewBox = document.getElementById('lottie-preview');
        if (currentLottieAnimation) {
            currentLottieAnimation.destroy();
            currentLottieAnimation = null;
        }
        previewBox.innerHTML = '<div class="preview-placeholder">üîó Link ·Äë·Ää·Ä∑·Ä∫·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·ÄÄ ·Äí·ÄÆ·Äî·Ä±·Äõ·Ä¨·Äô·Äæ·Ä¨ Gift animation ·ÄÄ·Ä≠·ÄØ·Äï·Äº·Äû·Äï·Ä±·Ä∏·Äï·Ä´·Äú·Ä≠·Äô·Ä∫·Ä∑·Äô·Äö·Ä∫·Åã</div>';
        previewBox.classList.remove('active');
    }

    function resetUI() {
        const inputElement = document.getElementById('nftLink');
        // FIX: Only reset state if input is not in an invalid state.
        if (inputElement.getAttribute('data-valid') !== 'false') {
            document.getElementById('convertButton').style.display = 'block';
            document.getElementById('downloadJsonButton').style.display = 'none';
            document.getElementById('optimizeButton').style.display = 'none';
            document.getElementById('status').innerHTML = '';
            document.getElementById('status').className = '';
            document.getElementById('status').removeAttribute('aria-label');

            const convertButton = document.getElementById('convertButton');
            convertButton.disabled = true;
            convertButton.setAttribute('aria-disabled', 'true');
            convertButton.classList.remove('loading');
            hideSuccessAnimation();

            resetPreview();
            resetGiftDetails(); 
            fetchedLottieJsonText = null;
            lastLoadedNftId = null;
        }
    }
    
    function renderLottiePreview(json_data) {
        resetPreview();
        const previewBox = document.getElementById('lottie-preview');
        previewBox.classList.add('active');
        previewBox.setAttribute('aria-busy', 'true');

        currentLottieAnimation = lottie.loadAnimation({
            container: previewBox,
            renderer: 'svg',
            loop: true,
            autoplay: true,
            animationData: json_data
        });

        currentLottieAnimation.addEventListener('DOMLoaded', () => {
            previewBox.setAttribute('aria-busy', 'false');
        });
        currentLottieAnimation.addEventListener('error', () => {
            previewBox.innerHTML = '<div class="preview-placeholder" style="color: var(--validation-color-error); font-weight: bold;">‚ùå Error Rendering Animation (Lottie Data Corrupt)</div>';
            previewBox.setAttribute('aria-busy', 'false');
        });
        currentLottieAnimation.resize();
    }

    function updateProgress(step, totalSteps, message) {
        const statusDiv = document.getElementById('status');
        statusDiv.className = 'loading';
        const percentage = (step / totalSteps) * 100;
        // FIX: Ensure the spinner is prepended to the message for loading states.
        const messageWithSpinner = message.includes('spinner') ? message : `<span class="spinner"></span> ${message}`;

        statusDiv.innerHTML = `
            ${messageWithSpinner}
            <div class="progress-bar">
                <div class="progress-bar-fill" style="width: ${percentage.toFixed(0)}%;"></div>
            </div>
        `;
        statusDiv.setAttribute('aria-label', `Loading: Step ${step} of ${totalSteps}. ${message.replace(/<[^>]*>?/gm, '')}`);
    }

    // ===================================
    // GIFT DETAILS EXTRACTION LOGIC (UPDATED FOR OBJECTS)
    // ===================================

    /**
     * UPDATED FUNCTION: Extracts a single trait value and percentage from the structured HTML table.
     * It now returns an object { name: '...', percent: '...' }
     */
    function extractTraitFromTable(doc, label) {
        const thElements = Array.from(doc.querySelectorAll('.tgme_gift_table th'));

        for (const thElement of thElements) {
            if (thElement.textContent.trim().toLowerCase() === label.toLowerCase()) {
                 const tdElement = thElement.nextElementSibling;
                 if (tdElement) {
                     const innerHTML = tdElement.innerHTML.trim();
                     const textContent = tdElement.textContent.trim();

                     // Regex to find the percentage content (e.g., <mark>0.8%</mark>)
                     const percentMatch = innerHTML.match(/<mark>([^<]+)<\/mark>/i);
                     let percentage = percentMatch ? percentMatch[1].trim() : '';

                     // Clean the trait name by removing the percentage text
                     let name = textContent.replace(percentage, '').trim();
                     
                     // Remove any trailing spaces, commas, or " %" if not inside <mark>
                     name = name.replace(/[\s,]*%$/, '').trim(); 
                     
                     if (name === '' && percentage !== '') name = label; // Fallback to label if only percentage is left

                     return { name: name || 'Unknown', percent: percentage };
                 }
            }
        }
        return { name: 'Unknown', percent: '' };
    }

    /**
     * Extracts Owner, Quantity, and Gifted Details from the structured HTML table and footer.
     * @param {Document} doc - The parsed HTML document.
     * @returns {Object} An object containing owner, quantity, and gifted details.
     */
    function extractOwnerAndQuantityFromTable(doc) {
        let owner = 'Unknown';
        let quantity = 'Unknown';
        let giftedBy = 'Unknown';
        let giftedTo = 'Unknown';
        let giftedDate = 'Unknown';

        // 1. Owner: Scrape the <td> content next to the <th>Owner</th>
        const ownerTh = Array.from(doc.querySelectorAll('.tgme_gift_table th')).find(th => th.textContent.trim() === 'Owner');
        if (ownerTh) {
            const ownerTd = ownerTh.nextElementSibling;
            if (ownerTd) {
                // Owner name might be wrapped in a <span> after other elements
                const span = ownerTd.querySelector('span[dir="auto"]');
                owner = span ? span.textContent.trim() : ownerTd.textContent.trim().split(' ')[0].replace(/[\(\)\[\]#]/g, '');
            }
        }

        // 2. Quantity: Scrape the <td> content next to the <th>Quantity</th>
        const quantityTh = Array.from(doc.querySelectorAll('.tgme_gift_table th')).find(th => th.textContent.trim() === 'Quantity');
        if (quantityTh) {
            const quantityTd = quantityTh.nextElementSibling;
            if (quantityTd) {
                quantity = quantityTd.textContent.trim();
                // Clean up: remove 'issued' and normalize space/slash
                quantity = quantity.replace(/issued/i, '').trim().replace(/\s*\/s*/, ' / '); 
            }
        }
        
        // 3. Gift Note: Scrape the footer <th> (which has colspan=2)
        const footerTh = doc.querySelector('.tgme_gift_table th.footer[colspan="2"]');
        if (footerTh) {
            const textContent = footerTh.textContent.trim();
            
            // Regex 3: Find Gift Details (Looks for "Gifted by [Sender] to [Recipient] on [Date]")
            const giftedMatch = textContent.match(/Gifted by\s*([^\n\r]+?)\s*to\s*([^\n\r]+?)\s*on\s*([^\n\r]+)/i);

            if (giftedMatch) {
                // Safely extract names from the anchor tags within the footer
                const senderAnchor = footerTh.querySelector('a:first-child');
                const recipientAnchor = footerTh.querySelector('a:last-child');
                
                giftedBy = senderAnchor ? senderAnchor.querySelector('span') ? senderAnchor.querySelector('span').textContent.trim() : senderAnchor.textContent.trim() : 'Unknown';
                giftedTo = recipientAnchor ? recipientAnchor.querySelector('span') ? recipientAnchor.querySelector('span').textContent.trim() : recipientAnchor.textContent.trim() : 'Unknown';
                
                // Final match is the date
                const dateMatch = textContent.match(/on\s*([^\n\r]+)$/i);
                giftedDate = dateMatch ? dateMatch[1].trim() : 'Unknown';
            } else {
                // Fallback for just Gifted on date
                const dateMatch = textContent.match(/Gifted on\s*([^\n\r]+)/i);
                if (dateMatch) {
                    giftedDate = dateMatch[1].trim();
                }
            }
        }

        return { owner, quantity, giftedBy, giftedTo, giftedDate };
    }


    /**
     * FALLBACK FUNCTION: Extracts trait values by looking for text content (used if table fails).
     * Returns a simple string.
     */
    function extractTrait(doc, traitName) {
        // Define the words that indicate the start of the next piece of data.
        const nextTraitStopWords = ['Backdrop:', 'Symbol:', 'Gifted by', 'Gifted on', 'Collected on', 'Owner:', 'issued', 'Model:'];
        
        // Create a regex to find the next trait name or stop word, making colons optional for matching.
        const stopRegex = new RegExp(`\\s+(${nextTraitStopWords.join('|').replace(/:/g, '\\s*:\\s*')})`, 'i');

        const divs = Array.from(doc.querySelectorAll('div'));
        
        for (const div of divs) {
            let textContent = div.textContent ? div.textContent.trim() : '';

            // --- 1. Look for text that STARTS with the Trait Name (e.g., "Model Gold Chain 2%") ---
            if (textContent.startsWith(traitName) || textContent.startsWith(traitName + ':')) {
                let fullValue = textContent.substring(traitName.length).trim();
                fullValue = fullValue.replace(/^[-\.:\s]*/, '').trim(); 
                
                // Cut the string at the first stop word found (only if it's not the first word)
                const match = fullValue.match(stopRegex);
                let finalValue = fullValue;
                if (match && match.index > 0) {
                    finalValue = fullValue.substring(0, match.index).trim();
                }
                
                // CRITICAL FINAL CLEANUP: Remove trailing percentages, numbers, and "issued" text
                // Since this is a fallback, we strip the % and <mark> to ensure clean text only.
                finalValue = finalValue.replace(/\s[\d\.,]+\s*%(.*)?$/, '').trim(); 
                finalValue = finalValue.replace(/\s[\d\.,]+\s*(%|issued)\s*$/, '').trim(); 
                
                return finalValue || 'Unknown';
            }
            
            // --- 2. Check for the structure: <div><b>TraitName</b>TraitValue</div> ---
            const bTag = div.querySelector('b');
            if (bTag && bTag.textContent && bTag.textContent.trim() === traitName) {
                let textValue = '';
                let textNode = bTag.nextSibling;
                while (textNode) {
                    if (textNode.nodeType === 3) { // 3 is TEXT_NODE
                        textValue += textNode.textContent;
                    }
                    if (textNode.nodeType === 1 && textNode !== bTag) break; 
                    textNode = textNode.nextSibling;
                }

                textValue = textValue.trim().replace(/^[-\.:\s]*/, '').trim();
                
                const match = textValue.match(stopRegex);
                let finalValue = textValue;
                if (match && match.index > 0) {
                    finalValue = textValue.substring(0, match.index).trim();
                }
                
                finalValue = finalValue.replace(/\s[\d\.,]+\s*%(.*)?$/, '').trim();
                finalValue = finalValue.replace(/\s[\d\.,]+\s*(%|issued)\s*$/, '').trim(); 
                
                return finalValue || 'Unknown';
            }
        }
        return 'Unknown';
    }


    // --- FALLBACK: Extracts Owner, Quantity, and Gifted Details from raw text content ---
    function extractOwnerAndQuantity(doc) {
        let owner = 'Unknown';
        let quantity = 'Unknown';
        let giftedBy = 'Unknown';
        let giftedTo = 'Unknown';
        let giftedDate = 'Unknown';

        const textContent = doc.body.textContent;

        // Regex 1: Find Owner (Looks for "Owner: [Name]")
        const ownerMatch = textContent.match(/Owner:\s*([^\n\r]+)/i);
        if (ownerMatch) {
            owner = ownerMatch[1].trim().split(' ')[0].replace(/[\(\)\[\]#]/g, '');
        }
        
        // Regex 2: Find Quantity (Looks for "[Number] / [Number] issued" or just "[Number] issued")
        const quantityMatch = textContent.match(/(\d[\d\s,]+)\s*(?:\/\s*(\d[\d\s,]+)\s*)?issued/i);
        if (quantityMatch) {
            quantity = quantityMatch[2] ? `${quantityMatch[1].trim()} / ${quantityMatch[2].trim()}` : `${quantityMatch[1].trim()}`;
            quantity = quantity.replace(/\s+/g, ''); // Remove all internal spaces
        }

        // Regex 3: Find Gift Details (Looks for "Gifted by [Sender] to [Recipient] on [Date]")
        const giftedMatch = textContent.match(/Gifted by\s*([^\n\r]+?)\s*to\s*([^\n\r]+?)\s*on\s*([^\n\r]+)/i);
        if (giftedMatch) {
            giftedBy = giftedMatch[1].trim();
            giftedTo = giftedMatch[2].trim();
            giftedDate = giftedMatch[3].trim();
        } else {
            // Fallback for just Gifted on date
            const dateMatch = textContent.match(/Gifted on\s*([^\n\r]+)/i);
            if (dateMatch) {
                giftedDate = dateMatch[1].trim();
            }
        }
        return { owner, quantity, giftedBy, giftedTo, giftedDate };
    }


    // **UPDATED: Handles new object structure for traits and includes nftLinkFull in the returned object.**
    async function fetchGiftDetailsFromHTML(nftLink, signal) {
        const proxyUrl = CORS_PROXY + encodeURIComponent(nftLink);
        let isError = false;

        let giftId = 'Unknown';
        // **Initialize as objects for table-based extraction**
        let model = { name: 'Unknown', percent: '' };
        let backdrop = { name: 'Unknown', percent: '' };
        let symbol = { name: 'Unknown', percent: '' };
        let ownerDetails = {};

        try {
            const response = await fetch(proxyUrl, { signal });
            
            if (!response.ok) {
                throw new Error(`Proxy Fetch Error (HTTP ${response.status})`);
            }

            const data = await response.json();
            const htmlText = data.contents;
            
            if (!htmlText) {
                throw new Error("Proxy returned empty content.");
            }

            // Parse HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, 'text/html');

            // üî• ATTEMPT 1: DIRECT TABLE EXTRACTION (Most Reliable)
            try {
                // **The extraction functions now return objects.**
                model = extractTraitFromTable(doc, 'Model');
                backdrop = extractTraitFromTable(doc, 'Backdrop');
                symbol = extractTraitFromTable(doc, 'Symbol');
                
                ownerDetails = extractOwnerAndQuantityFromTable(doc); 

                // Check if table extraction was successful (check the name property of the object)
                if (model.name !== 'Unknown' || backdrop.name !== 'Unknown' || symbol.name !== 'Unknown') {
                     // Get Gift ID from meta tag or title
                    const titleElement = doc.querySelector('meta[property="og:title"]') || doc.querySelector('title');
                    giftId = titleElement ? (titleElement.getAttribute('content') || titleElement.textContent).replace(/ #\d+/, '').trim() : 'Unknown';
                    
                    return { 
                        ...ownerDetails, 
                        giftId, 
                        model, // Returns the object
                        backdrop, // Returns the object
                        symbol, // Returns the object
                        nftLinkFull: nftLink, 
                        isError: false 
                    };
                }
            } catch (e) {
                console.warn("Table parsing failed, falling back to meta tags/text content.", e);
                // Continue to the next attempts if table parsing fails
            }


            // --- ATTEMPT 2: META DESCRIPTION TAG EXTRACTION & GENERIC DIV PARSING (Fallbacks) ---
            let strModel = 'Unknown';
            let strBackdrop = 'Unknown';
            let strSymbol = 'Unknown';

            try {
                const metaDescription = doc.querySelector('meta[name="twitter:description"]') || doc.querySelector('meta[property="og:description"]');
                if (metaDescription) {
                    const content = metaDescription.getAttribute('content');
                    if (content) {
                        const modelMatch = content.match(/Model:\s*([^,\n\r]+)/i);
                        const backdropMatch = content.match(/Backdrop:\s*([^,\n\r]+)/i);
                        const symbolMatch = content.match(/Symbol:\s*([^,\n\r]+)/i);

                        strModel = modelMatch ? modelMatch[1].trim() : strModel;
                        strBackdrop = backdropMatch ? backdropMatch[1].trim() : strBackdrop;
                        strSymbol = symbolMatch ? symbolMatch[1].trim() : strSymbol;
                    }
                }
            } catch (e) {
                console.warn("Meta description parsing failed.", e);
            }

            // --- ATTEMPT 3: GENERIC DIV PARSING (Fallback/Correction) ---
            const divModel = extractTrait(doc, 'Model');
            const divBackdrop = extractTrait(doc, 'Backdrop');
            const divSymbol = extractTrait(doc, 'Symbol');

            if (divModel !== 'Unknown') strModel = divModel;
            if (divBackdrop !== 'Unknown') strBackdrop = divBackdrop;
            if (divSymbol !== 'Unknown') strSymbol = divSymbol;
            
            // --- ATTEMPT 4: OG:IMAGE URL FALLBACK ---
            if (strModel === 'Unknown' || strBackdrop === 'Unknown' || strSymbol === 'Unknown') {
                const ogImage = doc.querySelector('meta[property="og:image"]');
                if (ogImage) {
                    const imageUrl = ogImage.getAttribute('content');
                    if (imageUrl) {
                        const urlMatch = imageUrl.match(/Model_([^-\/]+)-Backdrop_([^-\/]+)-Symbol_([^-\/]+)\.png/i);
                        if (urlMatch) {
                            const cleanAndFormat = (val) => val.replace(/([a-z])([A-Z])/g, '$1 $2').trim();

                            if (strModel === 'Unknown') strModel = cleanAndFormat(urlMatch[1]);
                            if (strBackdrop === 'Unknown') strBackdrop = cleanAndFormat(urlMatch[2]);
                            if (strSymbol === 'Unknown') strSymbol = cleanAndFormat(urlMatch[3]);
                        }
                    }
                }
            }

            // --- GIFT ID EXTRACTION (Final) ---
            const titleElement = doc.querySelector('meta[property="og:title"]') || doc.querySelector('title');
            const titleText = titleElement ? (titleElement.getAttribute('content') || titleElement.textContent).trim() : '';

            giftId = titleText
                .replace(/ #\d+/, '')
                .replace(/ ‚Äî Telegram$/, '')
                .replace(/ on Telegram$/, '')
                .replace(/NFT Gift: /, '')
                .replace(/Collectable Gift #\d+/, '')
                .trim();
            
            if (giftId === 'Unknown' || giftId === '') {
                const h1Element = doc.querySelector('h1') || doc.querySelector('.tgme_widget_message_link');
                giftId = h1Element ? h1Element.textContent.trim().replace(/ #\d+/, '').trim() : 'Unknown';
            }

            // --- FALLBACK OWNER/QUANTITY/GIFTED (If table/meta failed) ---
            if (Object.keys(ownerDetails).length === 0 || ownerDetails.owner === 'Unknown') {
                ownerDetails = extractOwnerAndQuantity(doc);
            }
            
            // Convert string fallbacks to the required object format for consistency in showGiftDetails
            const finalModel = { name: strModel, percent: '' };
            const finalBackdrop = { name: strBackdrop, percent: '' };
            const finalSymbol = { name: strSymbol, percent: '' };


            return { 
                giftId, 
                model: finalModel, 
                backdrop: finalBackdrop, 
                symbol: finalSymbol, 
                owner: ownerDetails.owner || 'Unknown', 
                quantity: ownerDetails.quantity || 'Unknown', 
                giftedBy: ownerDetails.giftedBy || 'Unknown', 
                giftedTo: ownerDetails.giftedTo || 'Unknown', 
                giftedDate: ownerDetails.giftedDate || 'Unknown', 
                nftLinkFull: nftLink,
                isError: false 
            };

        } catch (err) {
            if (err.name === 'AbortError') throw err; 
            console.error('Error fetching gift details:', err);
            isError = true;
            // Return error status with consistent object format
            return { 
                giftId: 'Unknown', 
                model: { name: 'Unknown', percent: '' }, 
                backdrop: { name: 'Unknown', percent: '' }, 
                symbol: { name: 'Unknown', percent: '' }, 
                owner: 'Unknown', 
                quantity: 'Unknown',
                giftedBy: 'Unknown',
                giftedTo: 'Unknown',
                giftedDate: 'Unknown',
                nftLinkFull: nftLink,
                isError: true 
            };
        }
    }


    // ===================================
    // AUTO-LOAD AND MAIN LOGIC 
    // ===================================
    async function handleAutoLoad() {
        const inputElement = document.getElementById('nftLink');
        const linkInput = inputElement.value.trim();
        const match = linkInput.match(LINK_REGEX);

        if (!match) {
            if (linkInput === '') resetUI();
            return;
        }

        const newNftId = match[1];

        if (newNftId === lastLoadedNftId) {
            // If the same valid ID is already loaded, skip fetching but ensure buttons are correct
            document.getElementById('convertButton').disabled = false;
            document.getElementById('convertButton').setAttribute('aria-disabled', 'false');
            document.getElementById('downloadJsonButton').style.display = 'block';
            return;
        }

        if (fetchAbortController) {
            fetchAbortController.abort();
        }
        fetchAbortController = new AbortController();
        const signal = fetchAbortController.signal;

        currentNftId = newNftId;
        const lottieUrl = LOTTIE_FRAGMENT_BASE + `${currentNftId}.lottie.json`;
        const nftLinkFull = `https://t.me/nft/${currentNftId}`;

        // Reset UI elements and show spinner
        document.getElementById('downloadJsonButton').style.display = 'none';
        document.getElementById('optimizeButton').style.display = 'none';
        fetchedLottieJsonText = null;
        resetGiftDetails();

        const previewBox = document.getElementById('lottie-preview');
        resetPreview();
        previewBox.classList.add('active');
        previewBox.innerHTML = `<div class="preview-placeholder"><span class="spinner"></span> Loading ${currentNftId} details...</div>`;

        try {
            // Fetch both Lottie JSON and HTML details in parallel
            const [lottieData, giftDetails] = await Promise.all([
                fetchLottieData(currentNftId, lottieUrl, true, signal),
                fetchGiftDetailsFromHTML(nftLinkFull, signal)
            ]);

            // Always display the details we found, or the error state
            showGiftDetails(giftDetails, giftDetails.isError);

            if (lottieData) {
                renderLottiePreview(lottieData);
                lastLoadedNftId = currentNftId;

                document.getElementById('status').innerHTML = '';
                document.getElementById('status').className = '';
                document.getElementById('convertButton').disabled = false;
                document.getElementById('convertButton').setAttribute('aria-disabled', 'false');
                document.getElementById('downloadJsonButton').style.display = 'block';
            } else {
                lastLoadedNftId = null;
                document.getElementById('convertButton').disabled = true;
                document.getElementById('convertButton').setAttribute('aria-disabled', 'true');
                document.getElementById('lottie-preview').innerHTML = '<div class="preview-placeholder" style="color: var(--validation-color-error); font-weight: bold;">‚ùå Error: Gift Lottie not found or network failed.</div>';
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Fetch aborted for new input.');
                return;
            }
            lastLoadedNftId = null;
            document.getElementById('lottie-preview').innerHTML = '<div class="preview-placeholder" style="color: var(--validation-color-error); font-weight: bold;">‚ùå Error: Network failed to fetch data.</div>';
            console.error("Auto-load failed:", error);
            
            // If there's a fatal error, still try to show the gift details error state
            showGiftDetails({ 
                giftId: 'Unknown', 
                model: { name: 'Unknown', percent: '' }, 
                backdrop: { name: 'Unknown', percent: '' }, 
                symbol: { name: 'Unknown', percent: '' }, 
                owner: 'Unknown', 
                quantity: 'Unknown', 
                giftedBy: 'Unknown', 
                giftedTo: 'Unknown', 
                giftedDate: 'Unknown', 
                nftLinkFull: nftLinkFull 
            }, true); 

        } finally {
            fetchAbortController = null;
        }
    }
    
    async function fetchLottieData(nftId, lottieUrl, isAutoLoad = false, signal = null) {
        
        if (!isAutoLoad) {
            updateProgress(1, 3, `‚è≥ Step 1/3: ·Ä°·ÄÅ·Äª·ÄÄ·Ä∫·Ä°·Äú·ÄÄ·Ä∫·Äô·Äª·Ä¨·Ä∏·ÄÄ·Ä≠·ÄØ ${nftId} ·Äô·Äæ·Äö·Ä∞·Äî·Ä±·Äï·Ä´·Äê·Äö·Ä∫·Åã`);
        }

        try {
            const response = await fetch(lottieUrl, { signal });

            if (!response.ok) {
                throw new Error(`Fetch Error (HTTP ${response.status})`);
            }

            const text = await response.text();
            fetchedLottieJsonText = text;
            const jsonData = JSON.parse(text);

            if (!isAutoLoad) {
                renderLottiePreview(jsonData);
            }

            return jsonData;

        } catch (error) {
            if (error.name === 'AbortError') throw error;

            if (!isAutoLoad) {
                document.getElementById('status').className = 'error';
                document.getElementById('status').innerHTML = `‚ùå Error ·Ä°·ÄÅ·Äª·ÄÄ·Ä∫·Ä°·Äú·ÄÄ·Ä∫·Äô·Äª·Ä¨·Ä∏ ·Äô·Äõ·Äö·Ä∞·Äî·Ä≠·ÄØ·ÄÑ·Ä∫·ÄÅ·Ä≤·Ä∑·Äï·Ä´·Åãü•π ${error.message}`;
                resetPreview();
            }
            return null;
        }
    }
    
    function convertAndDownload() {
        const convertButton = document.getElementById('convertButton');

        if (!validateInput()) {
            return;
        }

        convertButton.classList.add('loading');
        convertButton.setAttribute('aria-disabled', 'true'); 

        if (!fetchedLottieJsonText) {
            const linkInput = document.getElementById('nftLink').value.trim();
            const match = linkInput.match(LINK_REGEX);
            if (!match) { convertButton.classList.remove('loading'); convertButton.setAttribute('aria-disabled', 'false'); return; }

            currentNftId = match[1];
            const lottieUrl = LOTTIE_FRAGMENT_BASE + `${currentNftId}.lottie.json`;

            // Re-fetch Lottie Data if not present
            fetchLottieData(currentNftId, lottieUrl, false).then(() => {
                if (!fetchedLottieJsonText) {
                    convertButton.classList.remove('loading');
                    convertButton.setAttribute('aria-disabled', 'false');
                    return;
                }
                // Continue with compression/download logic here
                performCompressionAndDownload(convertButton);
            });
            return;
        }
        
        // If Lottie JSON is already available, perform compression/download immediately
        performCompressionAndDownload(convertButton);
    }

    function performCompressionAndDownload(convertButton) {
        const statusDiv = document.getElementById('status');

        try {
            const jsonToCompressText = fetchedLottieJsonText;

            updateProgress(2, 3, `<span class="spinner"></span> **Step 2/3:** Compressing Lottie JSON to **.tgs** format and checking size...`);

            const jsonBytes = new TextEncoder().encode(jsonToCompressText);
            const tgsBytes = pako.gzip(jsonBytes);
            const tgsSizeKB = (tgsBytes.length / 1024).toFixed(2);

            if (tgsBytes.length >= TELEGRAM_TGS_LIMIT_BYTES) {
                document.getElementById('convertButton').style.display = 'none';
                document.getElementById('downloadJsonButton').style.display = 'block';
                document.getElementById('optimizeButton').style.display = 'block';

                statusDiv.className = 'error';
                statusDiv.innerHTML = `
                    ‚ùå File Size ·Ä°·Äõ·Äô·Ä∫·Ä∏·ÄÄ·Äº·ÄÆ·Ä∏·Äî·Ä±·Äï·Ä´·Äê·Äö·Ä∫·Åã<br>
                    Sticker size ·ÄÄ **${tgsSizeKB} KB** (Limit: ${TELEGRAM_TGS_LIMIT_KB} KB).<br>
                    Telegram ·Äò·ÄÄ·Ä∫·ÄÄ·Äú·ÄÄ·Ä∫·Äô·ÄÅ·Ä∂·Äê·Ä≤·Ä∑·Ä°·Äê·ÄΩ·ÄÄ·Ä∫·ÄÄ·Äº·Ä±·Ä¨·ÄÑ·Ä∫·Ä∑ ·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·ÄÄ·ÄÅ·Äú·ÄØ·Äê·Ä∫·ÄÄ·Ä≠·ÄØ·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Äº·ÄÆ·Ä∏·Äï·Äº·ÄÑ·Ä∫·Äï·Ä´·Åã
                `;
                return;
            }

            updateProgress(3, 3, `üöÄ Step 3/3: Size ·ÄÖ·ÄÖ·Ä∫·ÄÜ·Ä±·Ä∏·Äô·Äæ·ÄØ·Ä∑·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫·Äï·Ä´·Äê·Äö·Ä∫·Åãü•≥ (${tgsSizeKB} KB). ·ÄÖ·Äê·ÄÑ·Ä∫download ·ÄÜ·ÄΩ·Ä≤·Äî·Ä±·Äï·Ä´·Äï·Äº·ÄÆ·Åã`);

            const tgsBlob = new Blob([tgsBytes], { type: 'application/x-tgsticker' });
            const downloadLink = document.createElement('a');
            const tempUrl = URL.createObjectURL(tgsBlob);

            downloadLink.href = tempUrl;
            downloadLink.download = `${currentNftId}.tgs`;

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            URL.revokeObjectURL(tempUrl);

            showSuccessAnimation();

            statusDiv.className = 'success';
            statusDiv.innerHTML = `
                ‚úÖ ·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫ ${currentNftId} sticker ·ÄÄ·Ä≠·ÄØ Download·ÄÜ·ÄΩ·Ä≤·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·Äï·Äº·ÄÆ·Åãü•∞<br>
                Size ${tgsSizeKB} KB.
            `;

            document.getElementById('downloadJsonButton').style.display = 'block';

        } catch (error) {
            resetUI();
            statusDiv.className = 'error';
            statusDiv.innerHTML = `üí• System Error ·Äò·Ä¨ error ·Äñ·Äº·ÄÖ·Ä∫·Äô·Äæ·Äî·Ä∫·Ä∏·Äô·Äû·Ä≠·Äê·Ä±·Ä¨·Ä∑·Äï·Ä´·Äò·Ä∞·Ä∏üò≠ ${error.message}`;
            console.error(error);
        } finally {
            convertButton.classList.remove('loading');
            convertButton.setAttribute('aria-disabled', 'false');
        }
    }

    function downloadRawJson() {
         const linkInput = document.getElementById('nftLink').value.trim();
        const match = linkInput.match(LINK_REGEX);
        if (!match) return; 

        const nftId = match[1];
        const statusDiv = document.getElementById('status');
        statusDiv.className = 'loading';
        statusDiv.innerHTML = '<span class="spinner"></span> Downloading raw JSON...';

        try {
            let lottieJsonText = fetchedLottieJsonText;

            if (!lottieJsonText) {
                fetch(LOTTIE_FRAGMENT_BASE + `${nftId}.lottie.json`).then(response => {
                    if (!response.ok) {
                        statusDiv.className = 'error';
                        statusDiv.innerHTML = `‚ùå Error ·Ä°·ÄÅ·Äª·ÄÄ·Ä∫·Ä°·Äú·ÄÄ·Ä∫·Äô·Äª·Ä¨·Ä∏·Äô·Äê·ÄΩ·Ä±·Ä∑·ÄÅ·Ä≤·Ä∑·Äï·Ä´·Åãü•∫`;
                        return;
                    }
                    return response.text();
                }).then(text => {
                     if (!text) return;
                     const jsonBlob = new Blob([text], { type: 'application/json' });
                     const downloadLink = document.createElement('a');
                     const tempUrl = URL.createObjectURL(jsonBlob);

                     downloadLink.href = tempUrl;
                     downloadLink.download = `${nftId}.json`;

                     document.body.appendChild(downloadLink);
                     downloadLink.click();
                     document.body.removeChild(downloadLink);

                     URL.revokeObjectURL(tempUrl);

                     statusDiv.className = 'success';
                     statusDiv.innerHTML = `‚úÖ ·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫·ÄÖ·ÄΩ·Ä¨ ${nftId}.json ·ÄÄ·Ä≠·ÄØ Download ·ÄÜ·ÄΩ·Ä≤·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·Äï·Äº·ÄÆ`;
                }).catch(error => {
                    statusDiv.className = 'error';
                    statusDiv.innerHTML = `üí• System Error ·Äò·Ä¨ error ·Äñ·Äº·ÄÖ·Ä∫·Äô·Äæ·Äî·Ä∫·Ä∏·Äô·Äû·Ä≠·Äê·Ä±·Ä¨·Ä∑·Äï·Ä´·Äò·Ä∞·Ä∏üò≠ ${error.message}`;
                    console.error(error);
                });
                return;
            }


            const jsonBlob = new Blob([lottieJsonText], { type: 'application/json' });
            const downloadLink = document.createElement('a');
            const tempUrl = URL.createObjectURL(jsonBlob);

            downloadLink.href = tempUrl;
            downloadLink.download = `${nftId}.json`;

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            URL.revokeObjectURL(tempUrl);

            statusDiv.className = 'success';
            statusDiv.innerHTML = `‚úÖ ·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫·ÄÖ·ÄΩ·Ä¨ ${nftId}.json ·ÄÄ·Ä≠·ÄØ Download ·ÄÜ·ÄΩ·Ä≤·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·Äï·Äº·ÄÆ`;

        } catch (error) {
            statusDiv.className = 'error';
            statusDiv.innerHTML = `üí• System Error ·Äò·Ä¨ error ·Äñ·Äº·ÄÖ·Ä∫·Äô·Äæ·Äî·Ä∫·Ä∏·Äô·Äû·Ä≠·Äê·Ä±·Ä¨·Ä∑·Äï·Ä´·Äò·Ä∞·Ä∏üò≠ ${error.message}`;
            console.error(error);
        }
    }
    
    function openOptimizationTool() {
        // Directs user to a Lottie optimization tool
        const editorBaseUrl = 'https://lottiefiles.com/optimise'; 
        window.open(editorBaseUrl, '_blank');
    }

    function applyTheme(isDarkMode) {
        const body = document.body;
        const toggleIcon = document.getElementById('themeIcon');
        if (isDarkMode) {
            body.classList.add('dark-mode');
            toggleIcon.innerHTML = '‚òÄÔ∏è';
        } else {
            body.classList.remove('dark-mode');
            toggleIcon.innerHTML = 'üåô';
        }
    }

    function toggleTheme() {
        const isDarkMode = document.body.classList.contains('dark-mode');
        const newMode = !isDarkMode;
        applyTheme(newMode);
        localStorage.setItem('darkMode', newMode ? 'true' : 'false');
    }

    function validateInput() {
        const inputElement = document.getElementById('nftLink');
        const linkInput = inputElement.value.trim();
        const isValid = LINK_REGEX.test(linkInput);
        const validationIcon = document.getElementById('validationIcon');
        const convertButton = document.getElementById('convertButton');

        if (linkInput === '') {
            inputElement.removeAttribute('data-valid');
            validationIcon.style.opacity = 0;
            convertButton.disabled = true;
            convertButton.setAttribute('aria-disabled', 'true');
            resetUI();
            return false;
        }

        inputElement.setAttribute('data-valid', isValid ? 'true' : 'false');
        validationIcon.innerHTML = isValid ? '‚úÖ' : '‚ùå';
        validationIcon.style.opacity = 1;

        convertButton.disabled = !isValid;
        convertButton.setAttribute('aria-disabled', !isValid);

        if (!isValid) {
            document.getElementById('status').className = 'error';
            document.getElementById('status').innerHTML = 'üõë Link ·Äô·Äæ·Ä¨·Ä∏ ·Äî·Ä±·Äï·Ä´·Äê·Äö·Ä∫·Åã <code>t.me/nft/NFT-ID</code>.';
            resetPreview();
            resetGiftDetails();
        }

        return isValid;
    }

    function showSuccessAnimation() {
        const container = document.getElementById('success-lottie-container');
        if (container && successLottieAnimation) {
            container.classList.add('show');
            successLottieAnimation.goToAndPlay(0, true);
            setTimeout(hideSuccessAnimation, 2000);
        }
    }

    function hideSuccessAnimation() {
        const container = document.getElementById('success-lottie-container');
        if (container && successLottieAnimation) {
            successLottieAnimation.stop();
            container.classList.remove('show');
        }
    }


    document.addEventListener('DOMContentLoaded', () => {
        // Attach main event listeners
        const nftLinkInput = document.getElementById('nftLink');
        
        document.getElementById('convertButton').addEventListener('click', convertAndDownload);
        document.getElementById('downloadJsonButton').addEventListener('click', downloadRawJson);
        document.getElementById('optimizeButton').addEventListener('click', openOptimizationTool);
        document.getElementById('themeToggle').addEventListener('click', toggleTheme);
        
        // Unified input/paste listeners for validation and auto-load
        const inputHandler = () => { validateInput(); handleAutoLoad(); };

        nftLinkInput.addEventListener('paste', function(event) {
            setTimeout(inputHandler, 50); // Use timeout for paste to get the value after it's applied
        });
        nftLinkInput.addEventListener('input', inputHandler);

        // Initialize theme immediately
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedTheme = localStorage.getItem('darkMode');
        let initialMode = savedTheme === 'true';
        if (savedTheme === null) {
            initialMode = prefersDark;
        }
        applyTheme(initialMode);

        // Initialize success Lottie animation (hidden by default)
        const successContainer = document.getElementById('success-lottie-container');
        if (successContainer) {
            successLottieAnimation = lottie.loadAnimation({
                container: successContainer,
                renderer: 'svg',
                loop: false,
                autoplay: false,
                animationData: successCheckmarkLottie
            });
        }

        // Manually run validation/load on page load if input has content
        validateInput();
        handleAutoLoad();
    });


    (function() {
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let w, h;

        class Particle {
            constructor() {
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.radius = Math.random() * 2 + 1;
                this.vx = Math.random() * 0.5 - 0.25;
                this.vy = Math.random() * 0.5 - 0.25;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--particle-color') || 'rgba(23, 63, 95, 0.5)';
                ctx.fill();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0) this.x = w;
                if (this.x > w) this.x = 0;
                if (this.y < 0) this.y = h;
                if (this.y > h) this.y = 0;
            }
        }

        function initParticles() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            particles = [];
            const particleCount = w < 600 ? 40 : 80;
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function startAnimationLoop() {
            animationId = requestAnimationFrame(startAnimationLoop);
            ctx.clearRect(0, 0, w, h);

            particles.forEach(p => {
                p.update();
                p.draw();
            });
            
            // Re-check theme on animation frame in case variables change for particle color
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--particle-color') || 'rgba(23, 63, 95, 0.5)';
        }

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cancelAnimationFrame(animationId);
            } else {
                startAnimationLoop();
            }
        });


        initParticles();
        startAnimationLoop();
        window.addEventListener('resize', initParticles);
    })();
</script>
</body>
</html>
