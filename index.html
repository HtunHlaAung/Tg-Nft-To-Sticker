<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MagicMall NFT Converter</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght{600;700}&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <style>
        /* CSS VARIABLES */
        :root {
            /* Light Mode */
            --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(255, 255, 255, 0.8);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
            
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            
            --accent-primary: #3b82f6;
            --accent-glow: rgba(59, 130, 246, 0.4);
            --accent-gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            
            --input-bg: rgba(255, 255, 255, 0.9);
            --input-border: #e2e8f0;
            
            --success: #10b981;
            --error: #ef4444;
            --particle-color: rgba(30, 41, 59, 0.1); 
            --tg-card-bg: rgba(255,255,255,0.8);
            
            --icon-fill: #1e293b;
            
            /* CSS Spinner Variables */
            --spinner-size: 30px;
            --spinner-border: 4px;
        }

        .dark-mode {
            /* Dark Mode */
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #312e81 100%);
            --glass-bg: rgba(15, 23, 42, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            
            --accent-primary: #60a5fa;
            --accent-glow: rgba(96, 165, 250, 0.4);
            --accent-gradient: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            
            --input-bg: rgba(30, 41, 59, 0.6);
            --input-border: rgba(255, 255, 255, 0.1);
            
            --success: #34d399;
            --error: #f87171;
            --particle-color: rgba(255, 255, 255, 0.05); 
            --tg-card-bg: rgba(30, 41, 59, 0.4);
            
            --icon-fill: #f8fafc;
        }

        /* GLOBAL STYLES */
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-gradient);
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            padding-top: 80px; 
            padding-bottom: 50px;
            margin: 0;
            color: var(--text-primary);
            transition: color 0.3s ease;
            box-sizing: border-box;
            perspective: 1000px;
        }

        /* CONTAINER & GLASS EFFECTS */
        .container {
            position: relative;
            width: 100%;
            max-width: 460px;
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: var(--glass-shadow);
            padding: 40px;
            box-sizing: border-box;
            z-index: 10;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
        }
        
        .container:hover {
            transform: rotateX(1deg) rotateY(-1deg) scale(1.01);
            box-shadow: 0 16px 40px 0 rgba(31, 38, 135, 0.2);
        }

        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.75rem;
            font-weight: 700;
            margin: 0 0 10px 0;
            color: var(--text-primary);
            text-align: center;
            letter-spacing: -0.02em;
        }

        .description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        
        .description code {
            background: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85em;
        }
        .dark-mode .description code { background: rgba(255,255,255,0.1); }


        /* PREVIEW AREA */
        #lottie-preview {
            width: 100%;
            padding-bottom: 100%; 
            background: var(--input-bg);
            border-radius: 16px;
            margin-bottom: 24px;
            position: relative;
            overflow: hidden;
            border: 1px dashed var(--input-border);
            transition: border-color 0.3s ease;
        }
        
        #lottie-preview.active {
            border: 1px solid var(--accent-primary);
            box-shadow: 0 0 20px var(--accent-glow);
        }

        .preview-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            padding: 20px;
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        #lottie-preview svg {
            position: absolute;
            top: 0; left: 0; width: 100% !important; height: 100% !important;
        }
        
        /* CSS Spinner Styling */
        .css-spinner {
            display: none;
            width: var(--spinner-size);
            height: var(--spinner-size);
            border: var(--spinner-border) solid var(--text-secondary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 5px;
        }

        .preview-placeholder.loading .css-spinner {
            display: block;
        }

        /* INPUT GROUP & VALIDATION */
        .input-group {
            position: relative;
            margin-bottom: 20px;
            width: 100%;
            display: flex;
            align-items: center;
        }

        input[type="text"] {
            width: 100%;
            padding: 16px 80px 16px 16px; 
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: 'Inter', sans-serif;
            outline: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-sizing: border-box;
            z-index: 1; 
        }

        /* Input Focus Lighting */
        input[type="text"]:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px var(--accent-glow), 0 0 15px var(--accent-glow) inset;
        }
        
        input[data-valid="true"] { border-color: var(--success); }
        input[data-valid="false"] { border-color: var(--error); }

        /* Clear Button */
        #clearInputButton {
            position: absolute;
            right: 12px; 
            top: 50%;
            transform: translateY(-50%);
            background: var(--input-border);
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 50%; 
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none; 
            transition: all 0.2s ease;
            z-index: 10;
            padding: 0;
            line-height: 1;
        }
        
        #clearInputButton:hover {
            background: var(--text-secondary);
            color: white;
        }
        
        #clearInputButton.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* Validation Icon (Check/X) */
        .validation-icon {
            position: absolute;
            right: 44px; 
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.1rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 5;
            pointer-events: none;
            will-change: transform;
        }
        
        /* Status Bar Icon Animation */
        .validation-icon.animated {
            animation: iconPop 0.3s ease-out;
        }


        /* GIFT DETAILS & BUTTONS */
        #giftDetails {
            background: var(--tg-card-bg);
            border-radius: 12px;
            padding: 0;
            margin-bottom: 20px;
            border: 1px solid var(--glass-border);
            overflow: hidden;
            display: none;
        }

        .detail-line {
            display: flex;
            justify-content: space-between;
            padding: 12px 16px;
            font-size: 0.95rem;
            border-bottom: 1px solid rgba(128,128,128,0.1);
            color: var(--text-primary);
            align-items: flex-start;
        }
        .detail-line:last-child { border-bottom: none; }
        
        .detail-line strong {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .detail-value {
            text-align: right;
            font-weight: 600;
            max-width: 60%;
            word-wrap: break-word;
        }
        
        .percentage-mark {
            background: var(--accent-gradient);
            color: white;
            font-size: 0.75em;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
            font-weight: 700;
            vertical-align: middle;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        button {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--accent-gradient);
            color: white;
            border: none;
            padding: 16px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
        }

        button:hover:not(:disabled):not(.loading) {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px var(--accent-glow), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            filter: brightness(1.1);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            background: var(--text-secondary);
            opacity: 0.3;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        #downloadJsonButton, #optimizeButton {
            background: transparent;
            border: 2px solid var(--input-border);
            color: var(--text-primary);
            box-shadow: none;
        }
        #downloadJsonButton:hover, #optimizeButton:hover {
            border-color: var(--accent-primary);
            background: rgba(59, 130, 246, 0.05);
            color: var(--accent-primary);
        }

        button.loading::after {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            top: calc(50% - 10px);
            left: calc(50% - 10px);
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        button.loading { color: transparent; pointer-events: none; }


        /* STATUS AREA */
        #status-area { 
            margin-top: 25px; 
            position: relative; 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        #status {
            width: 100%;
            padding: 16px;
            border-radius: 12px;
            font-size: 0.95rem;
            line-height: 1.5;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(10px);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        #status.active { opacity: 1; transform: translateY(0); }
        
        #status.loading {
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
        }
        
        /* Dedicated Error Card Styling */
        #status.error {
            background: rgba(239, 68, 68, 0.2); 
            color: var(--error);
            border: 2px solid var(--error); 
            font-weight: 600; 
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.3); 
            padding: 20px; 
        }
        
        .dark-mode #status.error {
            background: rgba(248, 113, 113, 0.15); 
            box-shadow: 0 0 15px rgba(248, 113, 113, 0.4);
        }

        .error-action-hint {
            font-weight: 400; 
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        /* Update Success Status for consistency */
        #status.success {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
            border: 2px solid var(--success);
            font-weight: 600;
            padding: 20px;
        }

                /* --- PROGRESS BAR STYLING (Cooler Design) --- */
        .progress-bar {
            width: 100%;
            height: 10px; /* Thicker bar */
            background: var(--input-border); /* Subtle background base */
            border-radius: 5px;
            overflow: hidden;
            margin-top: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2); /* Inset shadow for depth */
        }
        .dark-mode .progress-bar { background: rgba(255, 255, 255, 0.15); box-shadow: inset 0 1px 3px rgba(255, 255, 255, 0.05); }
        
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background: var(--accent-gradient);
            transition: width 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smoother animation curve */
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            
            /* Add a subtle glow/shadow to the bar itself */
            box-shadow: 0 0 10px var(--accent-glow);
        }
        
        /* Neon Scanning Animation Overlay */
        #status.loading .progress-bar-fill:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 50%; /* Stripe width */
            height: 100%;
            background: linear-gradient(
                to right, 
                rgba(255, 255, 255, 0) 0%, 
                rgba(255, 255, 255, 0.4) 50%, 
                rgba(255, 255, 255, 0) 100%
            );
            transform: translateX(-100%);
            animation: neonScan 1.5s infinite linear;
            mix-blend-mode: screen; /* Makes the white stripe look like a moving light */
        }

        /* Stop animation when done/error */
        #status.success .progress-bar-fill:before, #status.error .progress-bar-fill:before {
            animation: none;
            content: none;
        }

        
        /* Only animate the stripe when loading */
        #status.loading .progress-bar-fill {
            animation: progressStripe 1s linear infinite;
        }
        /* Stop stripe animation when done/error */
        #status.success .progress-bar-fill, #status.error .progress-bar-fill {
            background-image: none;
            animation: none;
        }

        /* THEME TOGGLE */
        .theme-toggle {
            position: fixed; 
            top: 20px; right: 20px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            z-index: 100;
            width: 48px; height: 48px;
            padding: 10px; border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .theme-toggle:hover { 
            transform: translateY(-2px);
            background: var(--input-bg);
        }
        
        .theme-toggle svg {
            width: 100%; height: 100%;
            fill: var(--icon-fill);
            transition: transform 0.5s ease;
        }
        .dark-mode .theme-toggle svg {
            transform: rotate(90deg);
        }


                /* ANIMATIONS (Add this new keyframe) */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* PROGRESS BAR SCANNING KEYFRAME */
        @keyframes neonScan {
            0% { transform: translateX(-100%) skewX(-30deg); }
            100% { transform: translateX(200%) skewX(-30deg); }
        }

        @keyframes iconPop {
            0% { transform: translateY(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateY(-50%) scale(1.2); opacity: 1; }
            100% { transform: translateY(-50%) scale(1); opacity: 1; }
        }


        /* Success Lottie Position */
        #success-lottie-container {
            position: absolute;
            top: -50px; left: 50%; transform: translateX(-50%);
            width: 80px; height: 80px;
            z-index: 30; opacity: 0; pointer-events: none;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
            transition: opacity 0.3s;
        }
        #success-lottie-container.show { opacity: 1; }

        /* Canvas */
        #particle-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }

        /* Responsive */
        @media (max-width: 480px) {
            body { 
                padding-top: 70px;
            }
            .container { 
                padding: 30px 20px; 
                margin: 0 10px;
            }
            .theme-toggle { top: 15px; right: 15px; width: 40px; height: 40px; padding: 8px; }
        }
    </style>
</head>
<body>

    <canvas id="particle-canvas"></canvas>

    <button id="themeToggle" class="theme-toggle" aria-label="Toggle dark and light mode">
        <span id="themeIconWrapper"></span>
    </button>

    <div class="container">
        <h1>MagicMall NFT Converter</h1>

        <p class="description" id="input-description">Convert Telegram NFT Gifts to Stickers.<br>Enter link: <code>t.me/nft/NFT-ID</code></p>

        <div id="lottie-preview">
            <div class="preview-placeholder">
                <div id="loadingSpinnerContainer" class="css-spinner"></div>
                Animation Preview
            </div>
        </div>

        <div class="input-group">
            <input 
                type="text" 
                id="nftLink" 
                placeholder="Paste NFT link here..." 
                aria-describedby="input-description"
                aria-required="true"
                autocomplete="off"
            >
            <span class="validation-icon" id="validationIcon"></span>
            <button id="clearInputButton" aria-label="Clear input">‚úï</button>
        </div>
        
        <div id="giftDetails"></div>
        
        <div class="action-buttons">
            <button id="convertButton" disabled aria-disabled="true">Convert to Sticker</button>
            <button id="downloadJsonButton" style="display: none;">Download JSON üíæ</button>
            <button id="optimizeButton" style="display: none;">Optimize Tool üõ†Ô∏è</button>
        </div>

        <div id="status-area">
            <div id="success-lottie-container"></div>
            <div id="status" role="alert" aria-live="polite"></div>
        </div>
    </div>

  <script>
       // SVG Icons 
    const ICON_MOON = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.8-5.1-9.8-10.7C1.4,5.8,5.8,1.4,11.3,1.4c0.5,0,0.9,0.3,1.1,0.8c0.1,0.4,0,0.9-0.3,1.3C10.6,4.7,9.8,6.8,9.8,9c0,4.4,3.6,8,8,8c2.2,0,4.3-0.8,5.5-2.2c0.3-0.4,0.8-0.5,1.3-0.3c0.4,0.2,0.8,0.7,0.8,1.2c0,0.1,0,0.3,0,0.4c-0.5,3.3-2.6,6.1-5.6,7.8C17.5,25.3,14.8,22,12.1,22z"/></svg>`;
    const ICON_SUN = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12,4c0.6,0,1-0.4,1-1V2c0-0.6-0.4-1-1-1s-1,0.4-1,1v1C11,3.6,11.4,4,12,4z M6.3,6.3c0.4-0.4,0.4-1,0-1.4L5.6,4.2c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l0.7,0.7C5.3,6.7,5.9,6.7,6.3,6.3z M17.7,6.3c0.4,0.4,1,0.4,1.4,0l0.7-0.7c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-0.7,0.7C17.3,5.3,17.3,5.9,17.7,6.3z M12,8c-2.2,0-4,1.8-4,4s1.8,4,4,4s4-1.8,4-4S14.2,8,12,8z M2,13h1c0.6,0,1-0.4,1-1s-0.4-1-1-1H2c-0.6,0-1,0.4-1,1S1.4,13,2,13z M21,13h1c0.6,0,1-0.4,1-1s-0.4-1-1-1h-1c-0.6,0-1,0.4-1,1S20.4,13,21,13z M6.3,17.7c-0.4-0.4-1-0.4-1.4,0l-0.7,0.7c-0.4,0.4-0.4,1,0,1.4s1,0.4,1.4,0l0.7-0.7C6.7,18.7,6.7,18.1,6.3,17.7z M17.7,17.7c-0.4-0.4-0.4-1,0,1.4l0.7,0.7c0.4,0.4,1,0.4,1.4,0s0.4-1,0-1.4l-0.7-0.7C18.7,17.3,18.1,17.3,17.7,17.7z M12,20c-0.6,0-1,0.4-1,1v1c0,0.6,0.4,1,1,1s1-0.4,1-1v-1C13,20.4,12.6,20,12,20z"/></svg>`;

    // Global state variables
    const TELEGRAM_TGS_LIMIT_KB = 64; 
    const TELEGRAM_TGS_LIMIT_BYTES = TELEGRAM_TGS_LIMIT_KB * 1024;
    const LINK_REGEX = /t\.me\/nft\/([a-zA-Z0-9_-]+)/;
    const LOTTIE_FRAGMENT_BASE = 'https://nft.fragment.com/gift/';
    const CORS_PROXY = 'https://api.allorigins.win/get?url='; 

    let currentNftId = null;
    let currentLottieAnimation = null;
    let fetchedLottieJsonText = null;
    let lastLoadedNftId = null; 
    let successLottieAnimation = null; 
    let fetchAbortController = null;
    let statusMessageTimer = null; 
    let continuousProgressTimer = null; 

    // Simple Checkmark Lottie Data (for success animation) 
    const successCheckmarkLottie = {
        "v": "5.7.4", "fr": 30, "ip": 0, "op": 60, "w": 100, "h": 100, "nm": "Success Checkmark", "ddd": 0, "assets": [],
        "layers": [{"ddd": 0, "ind": 1, "ty": 4, "nm": "Checkmark", "sr": 1, "ks": {"o": {"a": 0, "k": 100, "ix": 11}, "rp": {"a": 0, "k": 0, "ix": 12}, "s": {"a": 0, "k": [100, 100, 100], "ix": 6}, "p": {"a": 0, "k": [50, 50, 0], "ix": 2}, "a": {"a": 0, "k": [0, 0, 0], "ix": 1}, "r": {"a": 0, "k": 0, "ix": 10}}, "ao": 0, "shapes": [{"ty": "gr", "nm": "Group 1", "it": [{"ty": "sh", "nm": "Path 1", "ind": 0, "ks": {"a": 0, "k": {"i": [[-1.2, 0], [0, -1.2], [1.2, 0]], "o": [[0, -1.2], [1.2, 0], [0, 1.2]], "v": [[28.5, 52.8], [42.6, 66.8], [71.5, 37.9]]}, "ix": 2}, "mn": "ADBEVectorShape", "hd": false}, {"ty": "st", "c": {"a": 0, "k": [0, 0.8, 0.4, 1], "ix": 3}, "o": {"a": 0, "k": 100, "ix": 4}, "w": {"a": 0, "k": 10, "ix": 5}, "lc": 1, "lj": 1, "ml": 4, "mn": "ADBEVectorGraphicStroke", "hd": false}, {"ty": "gr", "nm": "Group 2", "it": [], "mn": "ADBEVectorGroup", "hd": false}], "mn": "ADBEVectorGroup", "hd": false}], "bm": 0}]
    };

    /* ================= CORE UI DISPLAY FUNCTIONS ================= */

    function showGiftDetails(details, isError = false) { 
        const detailBox = document.getElementById("giftDetails");
        detailBox.innerHTML = '';
        
        const { giftId, model, backdrop, symbol, owner, quantity, giftedBy, giftedTo, giftedDate } = details;

        if (isError) {
            detailBox.style.display = "none";
            return;
        }

        const hasMetadata = Object.values(details).some(value => {
            if (typeof value === 'object' && value !== null) {
                return value.name && value.name !== "Unknown" && value.name !== "-";
            }
            return value && value !== "Unknown" && value !== "-";
        });
                    
        if (!hasMetadata) {
            detailBox.style.display = "none";
            return;
        }

        let htmlContent = '';

        const createDetailLine = (label, value) => {
            let displayValue = '';
            let actualValue = '';

            if (typeof value === 'object' && value !== null && value.name) {
                actualValue = value.name;
                if (value.percent) {
                    displayValue = `${actualValue} <span class="percentage-mark">${value.percent}</span>`;
                } else {
                    displayValue = actualValue;
                }
            } else {
                actualValue = typeof value === 'string' ? value : 'Unknown';
                displayValue = actualValue;
            }

            if (actualValue && actualValue !== 'Unknown' && actualValue !== '-') {
                return `<div class="detail-line">
                            <strong>${label}</strong>
                            <div class="detail-value">${displayValue}</div>
                        </div>`;
            }
            return '';
        };

        // Gift ID formatting
        let formattedGiftId = giftId;
        if (giftId && giftId !== 'Unknown' && giftId !== '-') {
            const idMatch = details.nftLinkFull ? details.nftLinkFull.match(/-(\d+)$/) : null;
            let numericId = idMatch ? idMatch[1] : '';
            if (numericId) formattedGiftId = `${giftId} #${numericId}`;
            
            const modelName = typeof model === 'object' && model.name ? model.name : (typeof model === 'string' ? model : '');
            const modelMatch = modelName.split(' ')[0];
            if (!modelName || modelName === 'Unknown' || giftId.toLowerCase() !== modelMatch.toLowerCase()) {
                htmlContent += createDetailLine('Gift ID', formattedGiftId);
            }
        }

        htmlContent += createDetailLine('Model', model);
        htmlContent += createDetailLine('Backdrop', backdrop);
        htmlContent += createDetailLine('Symbol', symbol);
        
        htmlContent += createDetailLine('Owner', owner);

        // Quantity formatting
        let formattedQuantity = quantity;
        if (quantity && quantity !== 'Unknown' && quantity !== '-') {
            formattedQuantity = quantity.replace(/[^0-9\/\s,]/g, '').trim(); 
            formattedQuantity = formattedQuantity.replace(/\s+/g, ''); 
            formattedQuantity = formattedQuantity.split('/').map(part => {
                let numStr = part.replace(/,/g, '').trim(); 
                return numStr.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,'); 
            }).join(' / '); 
        }
        htmlContent += createDetailLine('Quantity', formattedQuantity);

        // Gifted status formatting
        let giftNote = null;
        if (giftedBy && giftedBy !== 'Unknown' && giftedBy !== '-') {
            giftNote = (giftedTo && giftedTo !== 'Unknown') ? `by ${giftedBy} to ${giftedTo}` : `by ${giftedBy}`;
            if (giftedDate && giftedDate !== 'Unknown') giftNote += ` on ${giftedDate}`;
        } else if (giftedDate && giftedDate !== 'Unknown') {
             giftNote = `on ${giftedDate}`;
        }
        
        if (giftNote) {
            htmlContent += `<div class="detail-line">
                                <strong>Gifted</strong>
                                <div class="detail-value" style="font-size:0.85em; opacity:0.8;">${giftNote}</div> 
                            </div>`;
        }

        detailBox.innerHTML = htmlContent;
        detailBox.style.display = "block";
    }

    function resetGiftDetails() {
        const detailBox = document.getElementById("giftDetails");
        detailBox.innerHTML = ''; 
        detailBox.style.display = "none";
    }

    function resetPreview() {
        const previewBox = document.getElementById('lottie-preview');
        if (currentLottieAnimation) {
            currentLottieAnimation.destroy();
            currentLottieAnimation = null;
        }
        // Use the placeholder with the CSS spinner element
        previewBox.innerHTML = `<div class="preview-placeholder">
            <div id="loadingSpinnerContainer" class="css-spinner"></div>
            Animation Preview
        </div>`;
        previewBox.classList.remove('active');
        document.getElementById('loadingSpinnerContainer').style.display = 'none';
    }

    function startLoadingAnimations() {
        const previewPlaceholder = document.querySelector('#lottie-preview .preview-placeholder');
        const spinner = document.getElementById('loadingSpinnerContainer');

        resetPreview(); 
        if (previewPlaceholder) {
            previewPlaceholder.classList.add('loading');
        }
        if (spinner) {
            spinner.style.display = 'block';
        }
    }
    
    function stopLoadingAnimations() {
         const previewPlaceholder = document.querySelector('#lottie-preview .preview-placeholder');
         const spinner = document.getElementById('loadingSpinnerContainer');
         
         if (previewPlaceholder) {
            previewPlaceholder.classList.remove('loading');
         }
         if (spinner) {
            spinner.style.display = 'none';
         }
         stopContinuousProgress(); 
    }

    function resetUI() {
        const inputElement = document.getElementById('nftLink');
        const statusDiv = document.getElementById('status');
        
        document.getElementById('clearInputButton').classList.remove('active');
        stopContinuousProgress(0); 

        if (inputElement.getAttribute('data-valid') !== 'false') {
            document.getElementById('convertButton').style.display = 'block';
            document.getElementById('downloadJsonButton').style.display = 'none';
            document.getElementById('optimizeButton').style.display = 'none';
            
            statusDiv.innerHTML = '';
            statusDiv.className = '';
            statusDiv.classList.remove('active');

            const convertButton = document.getElementById('convertButton');
            convertButton.disabled = true;
            convertButton.setAttribute('aria-disabled', 'true');
            convertButton.classList.remove('loading');
            hideSuccessAnimation();

            resetPreview();
            resetGiftDetails(); 
            fetchedLottieJsonText = null;
            lastLoadedNftId = null;
        }
    }
    
    function renderLottiePreview(json_data) {
        stopLoadingAnimations();
        resetPreview(); 
        const previewBox = document.getElementById('lottie-preview');
        previewBox.classList.add('active');

        currentLottieAnimation = lottie.loadAnimation({
            container: previewBox,
            renderer: 'svg',
            loop: true,
            autoplay: true,
            animationData: json_data
        });
    }

    /**
     * Updates the progress bar with an explicit percentage value.
     * @param {number} percentage - The percentage (0-100) to set the bar to.
     * @param {string} message - The status message.
     * @param {boolean} isTemporary - If the message should disappear after a timeout.
     */
    function updateProgress(percentage, message, isTemporary = false) {
        const statusDiv = document.getElementById('status');
        if (statusMessageTimer) { clearTimeout(statusMessageTimer); statusMessageTimer = null; }

        // Clamp the percentage
        const clampedPercentage = Math.max(0, Math.min(100, percentage));
        
        statusDiv.className = 'loading active';
        statusDiv.innerHTML = `
            <div>${message}</div>
            <div class="progress-bar">
                <div class="progress-bar-fill" style="width: ${clampedPercentage.toFixed(0)}%;"></div>
            </div>
        `;

        if (isTemporary) {
             statusMessageTimer = setTimeout(() => { statusDiv.classList.remove('active'); }, 3000);
        }
    }
    
    /**
     * Starts a continuous, slow-filling progress bar simulation for initial fetch.
     */
    function startContinuousProgress() {
        const statusDiv = document.getElementById('status');
        statusDiv.className = 'loading active';
        let currentPercentage = 5; // Start at 5%
        const fillElement = document.querySelector('.progress-bar-fill');

        if (continuousProgressTimer) clearInterval(continuousProgressTimer);

        continuousProgressTimer = setInterval(() => {
            if (!fillElement) return stopContinuousProgress(0);

            // Cap the progress before 50% to wait for completion event, matching the auto-load flow
            if (currentPercentage < 45) {
                const increment = currentPercentage < 20 ? 2 : 0.5;
                currentPercentage += increment;
                if (currentPercentage > 45) currentPercentage = 45;
                fillElement.style.width = `${currentPercentage.toFixed(0)}%`;
            }
        }, 300); 
    }

    /**
     * Stops the continuous progress bar simulation and optionally sets a final percentage.
     * @param {number|null} finalPercentage - Percentage to set the bar to (e.g., 100 for success, 0 for reset).
     */
    function stopContinuousProgress(finalPercentage = null) {
        if (continuousProgressTimer) {
            clearInterval(continuousProgressTimer);
            continuousProgressTimer = null;
        }
        const fillElement = document.querySelector('.progress-bar-fill');
        if (fillElement && finalPercentage !== null) {
             fillElement.style.width = `${finalPercentage.toFixed(0)}%`;
        }
    }


    /**
     * Shows the final status, including error card styling and optional hint.
     * @param {string} className - 'success' or 'error'.
     * @param {string} message - The main status message.
     * @param {string|null} hint - An optional actionable hint for error cards.
     */
    function showFinalStatus(className, message, hint = null) {
        const statusDiv = document.getElementById('status');
        if (statusMessageTimer) { clearTimeout(statusMessageTimer); statusMessageTimer = null; }
        stopContinuousProgress(className === 'success' ? 100 : 0); 
        
        statusDiv.className = `${className} active`;
        
        // Add a hint for actionable errors
        let htmlContent = `<div>${message}</div>`;
        if (className === 'error' && hint) {
            htmlContent += `<div class="error-action-hint">${hint}</div>`;
        }
        
        statusDiv.innerHTML = htmlContent;
    }

    /* ================= LOGIC & EXTRACTION ================= */

    function extractTraitFromTable(doc, label) {
        const thElements = Array.from(doc.querySelectorAll('.tgme_gift_table th'));
        for (const thElement of thElements) {
            if (thElement.textContent.trim().toLowerCase() === label.toLowerCase()) {
                 const tdElement = thElement.nextElementSibling;
                 if (tdElement) {
                     const innerHTML = tdElement.innerHTML.trim();
                     const textContent = tdElement.textContent.trim();
                     const percentMatch = innerHTML.match(/<mark>([^<]+)<\/mark>/i);
                     let percentage = percentMatch ? percentMatch[1].trim() : '';
                     let name = textContent.replace(percentage, '').trim().replace(/[\s,]*%$/, '').trim();
                     if (name === '' && percentage !== '') name = label; 
                     return { name: name || 'Unknown', percent: percentage };
                 }
            }
        }
        return { name: 'Unknown', percent: '' };
    }

    function extractOwnerAndQuantityFromTable(doc) {
        let owner = 'Unknown';
        let quantity = 'Unknown';
        let giftedBy = 'Unknown';
        let giftedTo = 'Unknown';
        let giftedDate = 'Unknown';

        const ownerTh = Array.from(doc.querySelectorAll('.tgme_gift_table th')).find(th => th.textContent.trim() === 'Owner');
        if (ownerTh) {
            const ownerTd = ownerTh.nextElementSibling;
            if (ownerTd) {
                const span = ownerTd.querySelector('span[dir="auto"]');
                owner = span ? (span.querySelector('span') ? span.querySelector('span').textContent.trim() : span.textContent.trim()) : ownerTd.textContent.trim().split(' ')[0].replace(/[\(\)\[\]#]/g, '');
            }
        }

        const quantityTh = Array.from(doc.querySelectorAll('.tgme_gift_table th')).find(th => th.textContent.trim() === 'Quantity');
        if (quantityTh) {
            const quantityTd = quantityTh.nextElementSibling;
            if (quantityTd) {
                quantity = quantityTd.textContent.trim();
                quantity = quantity.replace(/issued/i, '').trim().replace(/\s*\/s*/, ' / '); 
            }
        }
        
        const footerTh = doc.querySelector('.tgme_gift_table th.footer[colspan="2"]');
        if (footerTh) {
            const textContent = footerTh.textContent.trim();
            const giftedMatch = textContent.match(/Gifted by\s*([^\n\r]+?)\s*to\s*([^\n\r]+?)\s*on\s*([^\n\r]+)/i);

            if (giftedMatch) {
                const senderAnchor = footerTh.querySelector('a:first-child');
                const recipientAnchor = footerTh.querySelector('a:last-child');
                
                giftedBy = senderAnchor ? (senderAnchor.querySelector('span') ? senderAnchor.querySelector('span').textContent.trim() : senderAnchor.textContent.trim()) : 'Unknown';
                giftedTo = recipientAnchor ? (recipientAnchor.querySelector('span') ? recipientAnchor.querySelector('span').textContent.trim() : recipientAnchor.textContent.trim()) : 'Unknown';
                
                const dateMatch = textContent.match(/on\s*([^\n\r]+)$/i);
                giftedDate = dateMatch ? dateMatch[1].trim() : 'Unknown';
            } else {
                const dateMatch = textContent.match(/Gifted on\s*([^\n\r]+)/i);
                if (dateMatch) {
                    giftedDate = dateMatch[1].trim();
                }
            }
        }

        return { owner, quantity, giftedBy, giftedTo, giftedDate };
    }

    function extractTrait(doc, traitName) {
        const nextTraitStopWords = ['Backdrop:', 'Symbol:', 'Gifted by', 'Gifted on', 'Collected on', 'Owner:', 'issued', 'Model:'];
        const stopRegex = new RegExp(`\\s+(${nextTraitStopWords.join('|').replace(/:/g, '\\s*:\\s*')})`, 'i');
        const divs = Array.from(doc.querySelectorAll('div'));
        
        for (const div of divs) {
            let textContent = div.textContent ? div.textContent.trim() : '';

            if (textContent.startsWith(traitName) || textContent.startsWith(traitName + ':')) {
                let fullValue = textContent.substring(traitName.length).trim();
                fullValue = fullValue.replace(/^[-\.:\s]*/, '', '').trim(); 
                
                const match = fullValue.match(stopRegex);
                let finalValue = fullValue;
                if (match && match.index > 0) {
                    finalValue = fullValue.substring(0, match.index).trim();
                }
                
                finalValue = finalValue.replace(/\s[\d\.,]+\s*%(.*)?$/, '').trim(); 
                finalValue = finalValue.replace(/\s[\d\.,]+\s*(%|issued)\s*$/, '').trim(); 
                
                return finalValue || 'Unknown';
            }
            
            const bTag = div.querySelector('b');
            if (bTag && bTag.textContent && bTag.textContent.trim() === traitName) {
                let textValue = '';
                let textNode = bTag.nextSibling;
                while (textNode) {
                    if (textNode.nodeType === 3) { 
                        textValue += textNode.textContent;
                    }
                    if (textNode.nodeType === 1 && textNode !== bTag) break; 
                    textNode = textNode.nextSibling;
                }

                textValue = textValue.trim().replace(/^[-\.:\s]*/, '').trim();
                
                const match = textValue.match(stopRegex);
                let finalValue = textValue;
                if (match && match.index > 0) {
                    finalValue = textValue.substring(0, match.index).trim();
                }
                
                finalValue = finalValue.replace(/\s[\d\.,]+\s*%(.*)?$/, '').trim();
                finalValue = finalValue.replace(/\s[\d\.,]+\s*(%|issued)\s*$/, '').trim(); 
                
                return finalValue || 'Unknown';
            }
        }
        return 'Unknown';
    }

    function extractOwnerAndQuantity(doc) {
        let owner = 'Unknown';
        let quantity = 'Unknown';
        let giftedBy = 'Unknown';
        let giftedTo = 'Unknown';
        let giftedDate = 'Unknown';

        const textContent = doc.body.textContent;

        const ownerMatch = textContent.match(/Owner:\s*([^\n\r]+)/i);
        if (ownerMatch) {
            owner = ownerMatch[1].trim().split(' ')[0].replace(/[\(\)\[\]#]/g, '');
        }
        
        const quantityMatch = textContent.match(/(\d[\d\s,]+)\s*(?:\/\s*(\d[\d\s,]+)\s*)?issued/i);
        if (quantityMatch) {
            quantity = quantityMatch[2] ? `${quantityMatch[1].trim()} / ${quantityMatch[2].trim()}` : `${quantityMatch[1].trim()}`;
            quantity = quantity.replace(/\s+/g, ''); 
        }

        const giftedMatch = textContent.match(/Gifted by\s*([^\n\r]+?)\s*to\s*([^\n\r]+?)\s*on\s*([^\n\r]+)/i);
        if (giftedMatch) {
            giftedBy = giftedMatch[1].trim();
            giftedTo = giftedMatch[2].trim();
            giftedDate = giftedMatch[3].trim();
        } else {
            const dateMatch = textContent.match(/Gifted on\s*([^\n\r]+)/i);
            if (dateMatch) {
                giftedDate = dateMatch[1].trim();
            }
        }
        return { owner, quantity, giftedBy, giftedTo, giftedDate };
    }

    async function fetchGiftDetailsFromHTML(nftLink, signal) {
        const proxyUrl = CORS_PROXY + encodeURIComponent(nftLink);
        let model = { name: 'Unknown', percent: '' };
        let backdrop = { name: 'Unknown', percent: '' };
        let symbol = { name: 'Unknown', percent: '' };
        let ownerDetails = {};
        let giftId = 'Unknown';

        try {
            const response = await fetch(proxyUrl, { signal });
            if (!response.ok) throw new Error(`Proxy Error`);
            const data = await response.json();
            const doc = new DOMParser().parseFromString(data.contents, 'text/html');

            // 1. Table Extraction (Primary)
            try {
                model = extractTraitFromTable(doc, 'Model');
                backdrop = extractTraitFromTable(doc, 'Backdrop');
                symbol = extractTraitFromTable(doc, 'Symbol');
                ownerDetails = extractOwnerAndQuantityFromTable(doc);
            } catch(e) { console.warn('Table parsing failed', e); }

            // 2. Meta/Fallback Extraction if Table failed
            if (model.name === 'Unknown') {
                 let strModel = extractTrait(doc, 'Model');
                 if(strModel === 'Unknown') {
                     // Try Meta tags
                      const meta = doc.querySelector('meta[name="twitter:description"]') || doc.querySelector('meta[property="og:description"]');
                      if(meta) {
                          const c = meta.content;
                          const m = c.match(/Model:\s*([^,\n\r]+)/i);
                          if(m) strModel = m[1].trim();
                      }
                 }
                 model = { name: strModel, percent: '' };
            }
            if (Object.keys(ownerDetails).length === 0 || ownerDetails.owner === 'Unknown') {
                ownerDetails = extractOwnerAndQuantity(doc);
            }

            // Gift ID Extraction
            const titleEl = doc.querySelector('meta[property="og:title"]') || doc.querySelector('title');
            if(titleEl) giftId = (titleEl.getAttribute('content') || titleEl.textContent).replace(/ #\d+/, '').replace(/ ‚Äî Telegram$/,'').replace(/ on Telegram$/,'').replace(/NFT Gift: /,'').replace(/Collectable Gift #\d+/,'').trim();
            if(giftId === 'Unknown') {
                 const h1 = doc.querySelector('h1') || doc.querySelector('.tgme_widget_message_link');
                 if(h1) giftId = h1.textContent.trim().replace(/ #\d+/, '').trim();
            }

            return { 
                ...ownerDetails, giftId, model, backdrop, symbol, nftLinkFull: nftLink, isError: false 
            };
        } catch (err) {
            if (err.name === 'AbortError') throw err;
            console.error(err);
            return { isError: true, nftLinkFull: nftLink, ...ownerDetails, model, backdrop, symbol, giftId };
        }
    }

    async function handleAutoLoad() {
        const inputElement = document.getElementById('nftLink');
        const linkInput = inputElement.value.trim();
        const match = linkInput.match(LINK_REGEX);
        const icon = document.getElementById('validationIcon');

        document.getElementById('clearInputButton').classList.toggle('active', linkInput.length > 0);

        if (!match) {
            if (linkInput === '') resetUI();
            return;
        }

        const newNftId = match[1];
        if (newNftId === lastLoadedNftId) {
            document.getElementById('convertButton').disabled = false;
            document.getElementById('convertButton').setAttribute('aria-disabled', 'false');
            document.getElementById('downloadJsonButton').style.display = 'block';
            return;
        }

        if (fetchAbortController) fetchAbortController.abort();
        fetchAbortController = new AbortController();
        const signal = fetchAbortController.signal;

        currentNftId = newNftId;
        const lottieUrl = LOTTIE_FRAGMENT_BASE + `${currentNftId}.lottie.json`;
        const nftLinkFull = `https://t.me/nft/${currentNftId}`;

        // Reset & Start Loading UI
        document.getElementById('downloadJsonButton').style.display = 'none';
        document.getElementById('optimizeButton').style.display = 'none';
        fetchedLottieJsonText = null;
        resetGiftDetails();
        startLoadingAnimations();
        
        // Start continuous progress bar simulation
        updateProgress(5, `STEP 1/2: Fetching details and animation...`);
        startContinuousProgress();

        try {
            const [lottieData, giftDetails] = await Promise.all([
                fetchLottieData(currentNftId, lottieUrl, true, signal),
                fetchGiftDetailsFromHTML(nftLinkFull, signal)
            ]);

            stopContinuousProgress(50); // Stop continuous fill when fetch is complete (set to 50% max)
            stopLoadingAnimations(); // Clears CSS spinner and placeholder

            showGiftDetails(giftDetails, giftDetails.isError);

            if (lottieData) {
                renderLottiePreview(lottieData);
                lastLoadedNftId = currentNftId;
                showFinalStatus('success', `Data loaded. Ready to convert.`);
                document.getElementById('convertButton').disabled = false;
                document.getElementById('convertButton').setAttribute('aria-disabled', 'false');
                document.getElementById('downloadJsonButton').style.display = 'block';
            } else {
                lastLoadedNftId = null;
                document.getElementById('convertButton').disabled = true;
                const previewBox = document.getElementById('lottie-preview');
                previewBox.innerHTML = '<div class="preview-placeholder" style="color:var(--error); font-weight:600;">Animation Not Found</div>';
                 showFinalStatus('error', 
                    'Animation not found.',
                    'Check the link for typos or try clearing the input and re-pasting.'
                );
            }
        } catch (error) {
            if (error.name === 'AbortError') return;
            lastLoadedNftId = null;
            stopContinuousProgress(0); 
            stopLoadingAnimations(); 
            const previewBox = document.getElementById('lottie-preview');
            previewBox.innerHTML = '<div class="preview-placeholder" style="color:var(--error); font-weight:600;">Network Error. Please try again.</div>';
            showFinalStatus('error', 
                `Failed to fetch details.`,
                'A network issue occurred. Ensure the link is correct and try again.'
            );
        } finally {
            fetchAbortController = null;
        }
    }
    
    async function fetchLottieData(nftId, lottieUrl, isAutoLoad = false, signal = null) {
        if (!isAutoLoad) {
             startLoadingAnimations();
             updateProgress(5, `STEP 1/2: Fetching ${nftId} metadata...`);
             startContinuousProgress(); 
        }
        try {
            const response = await fetch(lottieUrl, { signal });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const text = await response.text();
            fetchedLottieJsonText = text;
            const jsonData = JSON.parse(text);
            if (!isAutoLoad) {
                 stopContinuousProgress(50);
                 renderLottiePreview(jsonData);
            }
            return jsonData;
        } catch (error) {
            if (error.name === 'AbortError') throw error;
            if (!isAutoLoad) {
                stopContinuousProgress(0);
                showFinalStatus('error', `Fetch Error: ${error.message}`, 'Could not retrieve animation data from Fragment.');
                stopLoadingAnimations();
            }
            return null;
        }
    }
    
    function convertAndDownload() {
        const convertButton = document.getElementById('convertButton');
        if (!validateInput()) return;

        // If JSON is not loaded, start the fetch process first
        if (!fetchedLottieJsonText) {
             const linkInput = document.getElementById('nftLink').value.trim();
             const match = linkInput.match(LINK_REGEX);
             if(!match) { convertButton.classList.remove('loading'); convertButton.disabled = false; return; }
             currentNftId = match[1];
             
             convertButton.classList.add('loading');
             convertButton.disabled = true;
             updateProgress(5, `STEP 1/2: Re-fetching ${currentNftId} animation...`);
             startContinuousProgress();
             
             fetchLottieData(currentNftId, LOTTIE_FRAGMENT_BASE + `${currentNftId}.lottie.json`, false).then((data)=>{
                 if(!data) {
                     // Error status already shown in fetchLottieData
                     convertButton.classList.remove('loading'); 
                     convertButton.disabled = true; 
                     return;
                 }
                 performCompressionAndDownload(convertButton);
             });
             return;
        }
        
        // If JSON is already loaded, proceed directly
        performCompressionAndDownload(convertButton);
    }

    // UPDATED FOR RESPONSIVENESS AND TWO-STEP PROGRESS
    function performCompressionAndDownload(convertButton) {
        // Ensure buttons are disabled immediately
        convertButton.classList.add('loading');
        convertButton.disabled = true;

        try {
            // STEP 2: Compression Start (UI Update - Responsive)
            updateProgress(50, `STEP 2/2: Compressing to .TGS...`);

            // Use setTimeout to defer the heavy compression, allowing the UI thread to update the progress bar.
            setTimeout(() => {
                let success = false;
                try {
                    const jsonBytes = new TextEncoder().encode(fetchedLottieJsonText);
                    const tgsBytes = pako.gzip(jsonBytes);
                    const tgsSizeKB = (tgsBytes.length / 1024).toFixed(2);

                    // Size Check and Error Handling
                    if (tgsBytes.length >= TELEGRAM_TGS_LIMIT_BYTES) {
                        document.getElementById('convertButton').style.display = 'none';
                        document.getElementById('downloadJsonButton').style.display = 'block';
                        document.getElementById('optimizeButton').style.display = 'block';
                        
                        // Enhanced Error Card with Hint
                        showFinalStatus('error', 
                            `Size ${tgsSizeKB}KB exceeds 64KB limit. Cannot convert.`,
                            `Click 'Optimize Tool üõ†Ô∏è' to reduce file size, or download the JSON to optimize externally.`
                        );
                        return; 
                    }

                    // Successful Conversion and Download
                    updateProgress(90, `Finalizing and preparing download...`);
                    
                    const tgsBlob = new Blob([tgsBytes], { type: 'application/x-tgsticker' });
                    const tempUrl = URL.createObjectURL(tgsBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = tempUrl;
                    downloadLink.download = `${currentNftId}.tgs`;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(tempUrl);

                    showSuccessAnimation();
                    showFinalStatus('success', `Downloaded ${currentNftId}.tgs (${tgsSizeKB} KB)`);
                    document.getElementById('downloadJsonButton').style.display = 'block';
                    success = true;

                } catch (error) {
                    // General System Error Card with Hint
                    console.error("Compression/Download Error:", error);
                    showFinalStatus('error', 
                        `System Error: ${error.message}`,
                        `Check your browser console for technical details, or try clearing the input and re-pasting the link.`
                    );
                } finally {
                    // Re-enable button
                    convertButton.classList.remove('loading');
                    convertButton.disabled = success ? false : true; 
                }
            }, 50); // Small delay to allow progress bar to render
        
        } catch (error) {
            // This catch is for errors *before* the setTimeout
             console.error("Initial Compression Setup Error:", error);
             convertButton.classList.remove('loading');
             convertButton.disabled = false;
             showFinalStatus('error', 'Critical setup error occurred.', 'Please try refreshing the page.');
        }
    }
    
    function downloadRawJson() {
        const linkInput = document.getElementById('nftLink').value.trim();
        const match = linkInput.match(LINK_REGEX);
        if(!match) return;
        const nftId = match[1];
        if(fetchedLottieJsonText) {
            const blob = new Blob([fetchedLottieJsonText], {type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `${nftId}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showFinalStatus('success', 'JSON Downloaded.');
        }
    }
    
    function openOptimizationTool() { window.open('https://lottiefiles.com/optimise', '_blank'); }

    // Theme Logic 
    function applyTheme(isDarkMode) {
        const body = document.body;
        const toggleIconWrapper = document.getElementById('themeIconWrapper');
        if (isDarkMode) {
            body.classList.add('dark-mode');
            toggleIconWrapper.innerHTML = ICON_SUN; 
        } else {
            body.classList.remove('dark-mode');
            toggleIconWrapper.innerHTML = ICON_MOON; 
        }
        if (typeof initParticles === 'function') initParticles();
    }
    function toggleTheme() {
        const isDarkMode = document.body.classList.contains('dark-mode');
        applyTheme(!isDarkMode);
        localStorage.setItem('darkMode', !isDarkMode ? 'true' : 'false');
    }

    // Input Validation 
    function validateInput() {
        const inputElement = document.getElementById('nftLink');
        const linkInput = inputElement.value.trim();
        const isValid = LINK_REGEX.test(linkInput);
        const icon = document.getElementById('validationIcon');
        const btn = document.getElementById('convertButton');

        document.getElementById('clearInputButton').classList.toggle('active', linkInput.length > 0);

        if (linkInput === '') {
            inputElement.removeAttribute('data-valid');
            icon.style.opacity = 0;
            icon.classList.remove('animated');
            btn.disabled = true;
            resetUI();
            return false;
        }

        const wasValid = inputElement.getAttribute('data-valid') === 'true';

        inputElement.setAttribute('data-valid', isValid ? 'true' : 'false');
        icon.innerHTML = isValid ? '‚úì' : '‚úï';
        icon.style.color = isValid ? 'var(--success)' : 'var(--error)';
        icon.style.opacity = 1;
        btn.disabled = !isValid;
        
        if (isValid !== wasValid) {
            icon.classList.remove('animated');
            void icon.offsetWidth; 
            icon.classList.add('animated');
        }

        if (!isValid) {
            showFinalStatus('error', 'Invalid Link.', 'Format must be: t.me/nft/NFT-ID');
            resetPreview();
            resetGiftDetails();
        }
        return isValid;
    }
    
    function clearInput() {
        const input = document.getElementById('nftLink');
        input.value = '';
        input.removeAttribute('data-valid');
        document.getElementById('validationIcon').style.opacity = 0;
        document.getElementById('validationIcon').classList.remove('animated');
        document.getElementById('clearInputButton').classList.remove('active');
        resetUI();
        input.focus();
    }

    // Success Animation 
    function showSuccessAnimation() {
        const container = document.getElementById('success-lottie-container');
        if (container && successLottieAnimation) {
            container.classList.add('show');
            successLottieAnimation.goToAndPlay(0, true);
            setTimeout(() => { 
                successLottieAnimation.stop(); 
                container.classList.remove('show'); 
            }, 2000);
        }
    }
    function hideSuccessAnimation() {
         document.getElementById('success-lottie-container').classList.remove('show');
         if (successLottieAnimation) successLottieAnimation.stop();
    }

    // Initialization 
    document.addEventListener('DOMContentLoaded', () => {
        const input = document.getElementById('nftLink');
        
        document.getElementById('convertButton').addEventListener('click', convertAndDownload);
        document.getElementById('downloadJsonButton').addEventListener('click', downloadRawJson);
        document.getElementById('optimizeButton').addEventListener('click', openOptimizationTool);
        document.getElementById('themeToggle').addEventListener('click', toggleTheme);
        document.getElementById('clearInputButton').addEventListener('click', clearInput);
        
        const inputHandler = () => { validateInput(); handleAutoLoad(); };
        input.addEventListener('paste', () => setTimeout(inputHandler, 50));
        input.addEventListener('input', inputHandler);

        // Theme Init
        const savedTheme = localStorage.getItem('darkMode');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        applyTheme(savedTheme === 'true' || (savedTheme === null && prefersDark));

        // Success Anim Init
        const successContainer = document.getElementById('success-lottie-container');
        if (successContainer) {
            successLottieAnimation = lottie.loadAnimation({
                container: successContainer, renderer: 'svg', loop: false, autoplay: false, animationData: successCheckmarkLottie
            });
        }
        
        // Initial Check
        if(input.value) { validateInput(); handleAutoLoad(); }
    });


    // Particle System (Subtle Background) 
    (function() {
        const canvas = document.getElementById('particle-canvas');
        if (!canvas) return; 
        const ctx = canvas.getContext('2d');
        let particles = [];
        let w, h;
        
        window.initParticles = function() {
             w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight;
             particles = [];
             for (let i = 0; i < (w < 600 ? 30 : 60); i++) particles.push(new Particle());
        }

        class Particle {
            constructor() {
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.radius = Math.random() * 2 + 0.5;
                this.vx = Math.random() * 0.2 - 0.1;
                this.vy = Math.random() * 0.2 - 0.1;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                const particleColor = getComputedStyle(document.documentElement).getPropertyValue('--particle-color').trim() || 'rgba(100,100,100,0.1)';
                ctx.fillStyle = particleColor;
                ctx.fill();
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.x < 0) this.x = w; if (this.x > w) this.x = 0;
                if (this.y < 0) this.y = h; if (this.y > h) this.y = 0;
            }
        }
        
        function loop() {
            if (!canvas.isConnected) return;
            requestAnimationFrame(loop);
            ctx.clearRect(0, 0, w, h);
            particles.forEach(p => { p.update(); p.draw(); });
        }
        
        initParticles(); 
        loop();
        window.addEventListener('resize', initParticles);
    })();
</script>
</body>
</html>
